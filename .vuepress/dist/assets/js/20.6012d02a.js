(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{220:function(e,n,r){"use strict";r.r(n);var t=r(0),a=Object(t.a)({},(function(){var e=this,n=e.$createElement,r=e._self._c||n;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"docker架构分析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#docker架构分析"}},[e._v("#")]),e._v(" Docker架构分析")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("[root@docker-build-86-050 ~]# ls /usr/bin |grep docker\ndocker\ndocker-compose\ndocker-containerd\ndocker-containerd-ctr\ndocker-containerd-shim\ndockerd\ndocker-proxy\ndocker-runc\n")])])]),r("p",[e._v("大家一定很困惑 dockerd, containerd, ctr,shim, runc,等这几个进程的关系到底是啥\n")]),e._v(" "),r("p",[e._v("初窥得出的结论是：")]),e._v(" "),r("ul",[r("li",[e._v("docker是cli没啥可说的")]),e._v(" "),r("li",[e._v("dockerd是docker engine守护进程，dockerd启动时会启动containerd子进程。")]),e._v(" "),r("li",[e._v("dockerd与containerd通过rpc进行通信（待验证，可能是通过ctr）")]),e._v(" "),r("li",[e._v("ctr是containerd的cli")]),e._v(" "),r("li",[e._v("containerd通过shim操作runc，runc真正控制容器生命周期")]),e._v(" "),r("li",[e._v("启动一个容器就会启动一个shim进程")]),e._v(" "),r("li",[e._v("shim直接调用runc的包函数,shim与containerd之前通过rpc通信")]),e._v(" "),r("li",[e._v("真正用户想启动的进程由runc的init进程启动，即"),r("code",[e._v("runc init [args ...]")])])]),e._v(" "),r("p",[e._v("进程关系模型：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("docker     ctr\n  |         |\n  V         V\ndockerd -> containerd ---\x3e shim -> runc -> runc init -> process\n                      |-- > shim -> runc -> runc init -> process\n                      +-- > shim -> runc -> runc init -> process\n")])])]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("[root@docker-build-86-050 ~]# ps -aux|grep docker\nroot      3925  0.0  0.1 2936996 74020 ?       Ssl  3月06  68:14 /usr/bin/dockerd --storage-driver=aufs -H 0.0.0.0:2375 --label ip=10.1.86.50 -H unix:///var/run/docker.sock --insecure-registry 192.168.86.106 --insecure-registry 10.1.86.51 --insecure-registry dev.reg.iflytek.com\nroot      3939  0.0  0.0 1881796 27096 ?       Ssl  3月06   9:10 docker-containerd -l unix:///var/run/docker/libcontainerd/docker-containerd.sock --shim docker-containerd-shim --metrics-interval=0 --start-timeout 2m --state-dir /var/run/docker/libcontainerd/containerd --runtime docker-runc\nroot     21238  0.0  0.0 487664  6212 ?        Sl   4月20   0:00 docker-containerd-shim 48119c50a0ca8a53967364f75fb709017cc272ae248b78062e0dafaa22108d21 /var/run/docker/libcontainerd/48119c50a0ca8a53967364f75fb709017cc272ae248b78062e0dafaa22108d21 docker-runc\n")])])]),r("h2",{attrs:{id:"dockerd-与-containerd-之间的基情"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#dockerd-与-containerd-之间的基情"}},[e._v("#")]),e._v(" dockerd 与 containerd 之间的基情")]),e._v(" "),r("p",[e._v("首先dockerd的main函数相信你能找到"),r("code",[e._v("cmd/dockerd/docker.go")])]),e._v(" "),r("p",[e._v("其它的先略过,直接进start看一看：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("err = daemonCli.start(opts)\n")])])]),r("p",[e._v("这函数里我们先去关注两件事：")]),e._v(" "),r("ol",[r("li",[e._v("创建了多个Hosts，这是给client去连接的，dockerd启动时用-H参数指定，可以是多个，如指定一个tcp 指定一个unix sock( -H unix:///var/run/docker.sock)")]),e._v(" "),r("li",[e._v("创建了containerd子进程")])]),e._v(" "),r("p",[e._v("这个New很重要")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("containerdRemote, err := libcontainerd.New(cli.getLibcontainerdRoot(), cli.getPlatformRemoteOptions()...)\n")])])]),r("p",[e._v("进去看看：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('...\n    err := r.runContainerdDaemon(); \n...\n    conn, err := grpc.Dial(r.rpcAddr, dialOpts...)\n    if err != nil {\n        return nil, fmt.Errorf("error connecting to containerd: %v", err)\n    }\n\n    r.rpcConn = conn\n    r.apiClient = containerd.NewAPIClient(conn)\n...\n')])])]),r("p",[e._v("启动了一个containerd进程，并与之建立连接。通过protobuf进行rpc通信， grpc相关介绍看"),r("a",{attrs:{href:"http://lameleg.com/tech/rpc-protobuf.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("这里"),r("OutboundLink")],1)]),e._v(" "),r("p",[e._v("具体如何创建containerd进程的可以进入runContainerDaemon里细看")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('    cmd := exec.Command(containerdBinary, args...)\n    // redirect containerd logs to docker logs\n    cmd.Stdout = os.Stdout\n    cmd.Stderr = os.Stderr\n    cmd.SysProcAttr = setSysProcAttr(true)\n    cmd.Env = nil\n    // clear the NOTIFY_SOCKET from the env when starting containerd\n    for _, e := range os.Environ() {\n        if !strings.HasPrefix(e, "NOTIFY_SOCKET") {\n            cmd.Env = append(cmd.Env, e)\n        }\n    }\n    if err := cmd.Start(); err != nil {\n        return err\n    }\n')])])]),r("p",[e._v("看不明白的话，去标准库里恶补一下cmd怎么用。 cmd.Start()异步创建进程，创建完直接返回")]),e._v(" "),r("p",[e._v("所以创建一个协程等待子进程退出")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("    go func() {\n        cmd.Wait()\n        close(r.daemonWaitCh)\n    }() // Reap our child when needed\n\n")])])]),r("h2",{attrs:{id:"docker-containerd-shim是何方神圣-与containerd和runc又有什么关系？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#docker-containerd-shim是何方神圣-与containerd和runc又有什么关系？"}},[e._v("#")]),e._v(" docker-containerd-shim是何方神圣 与containerd和runc又有什么关系？")]),e._v(" "),r("p",[e._v("代码中的一句话解释："),r("code",[e._v("shim for container lifecycle and reconnection")]),e._v(", 容器生命周期和重连, 所以可以顺着这个思路去看。")]),e._v(" "),r("p",[e._v("先看containerd/linux/runtime.go里的一段代码：\nRuntime 的Create方法里有这一行,这里的Runtime对象也是注册到register里面的，可以看init函数，然后containerd进程启动时去加载了这个Runtime")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("s, err := newShim(path, r.remote)\n")])])]),r("p",[e._v("缩减版内容:")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('func newShim(path string, remote bool) (shim.ShimClient, error) {\n    l, err := sys.CreateUnixSocket(socket) //创建了一个UnixSocket\n    cmd := exec.Command("containerd-shim")\n    f, err := l.(*net.UnixListener).File()\n    cmd.ExtraFiles = append(cmd.ExtraFiles, f) //留意一下这个，非常非常重要，不知道这个原理可能就看不懂shim里面的代码了\n    if err := reaper.Default.Start(cmd); err != nil { //启动了一个shim进程\n    }\n    return connectShim(socket) // 这里返回了与shim进程通信的客户端\n}\n')])])]),r("p",[e._v("再去看看shim的代码：\nshim进程启动干的最主要的一件事就是启动一个grpc server:")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('if err := serve(server, "shim.sock"); err != nil {\n')])])]),r("p",[e._v("进去一探究竟：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('func serve(server *grpc.Server, path string) error {\n    l, err := net.FileListener(os.NewFile(3, "socket"))\n    logrus.WithField("socket", path).Debug("serving api on unix socket")\n    go func() {\n        if err := server.Serve(l); err != nil &&\n        }\n    }()\n}\n')])])]),r("p",[e._v("我曾经因为这个"),r("code",[e._v('os.NewFile(3, "socket")')]),e._v("看了半天看不懂，为啥是3？联系"),r("code",[e._v("cmd.ExtraFiles = append(cmd.ExtraFiles, f)")]),e._v(" 创建shim进程时的这句，问题解决了。")]),e._v(" "),r("p",[e._v("这个3的文件描述符，就是containerd用于创建UnixSocket的文件，这样containerd的client刚好与这边启动的 grpc server连接上了，可以远程调用其接口了：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("type ContainerServiceClient interface {\n    Create(ctx context.Context, in *CreateRequest, opts ...grpc.CallOption) (*CreateResponse, error)\n    Start(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)\n    Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error)\n    Info(ctx context.Context, in *InfoRequest, opts ...grpc.CallOption) (*containerd_v1_types1.Container, error)\n    List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error)\n    Kill(ctx context.Context, in *KillRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)\n    Events(ctx context.Context, in *EventsRequest, opts ...grpc.CallOption) (ContainerService_EventsClient, error)\n    Exec(ctx context.Context, in *ExecRequest, opts ...grpc.CallOption) (*ExecResponse, error)\n    Pty(ctx context.Context, in *PtyRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)\n    CloseStdin(ctx context.Context, in *CloseStdinRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)\n}\n\n")])])]),r("p",[r("a",{attrs:{href:"https://github.com/fanux/fanux.github.io/tree/master/demo/grpc",target:"_blank",rel:"noopener noreferrer"}},[e._v("containerd与shim通信模型介绍"),r("OutboundLink")],1)]),e._v(" "),r("p",[e._v("再看shim与runc的关系，这个比较简单了，直接进入shim service 实现的Create方法即可")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("sv = shim.New(path)\n")])])]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("func (s *Service) Create(ctx context.Context, r *shimapi.CreateRequest) (*shimapi.CreateResponse, error) {\n    process, err := newInitProcess(ctx, s.path, r)\n    return &shimapi.CreateResponse{\n        Pid: uint32(pid),\n    }, nil\n}\n")])])]),r("p",[e._v("进入到newInitProcess里面：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('func newInitProcess(context context.Context, path string, r *shimapi.CreateRequest) (*initProcess, error) {\n    runtime := &runc.Runc{\n        Command:      r.Runtime,\n        Log:          filepath.Join(path, "log.json"),\n        LogFormat:    runc.JSON,\n        PdeathSignal: syscall.SIGKILL,\n    }\n    p := &initProcess{\n        id:     r.ID,\n        bundle: r.Bundle,\n        runc:   runtime,\n    }\n  \n    if err := p.runc.Create(context, r.ID, r.Bundle, opts); err != nil {\n        return nil, err\n    }\n    return p, nil\n}\n')])])]),r("p",[e._v("可以看到，在这里调用了runc的API去真正执行创建容器的操作。其本质是调用了"),r("code",[e._v("runc create --bundle [bundle] [containerid]")]),e._v(" 命令,在此不多作介绍了")]),e._v(" "),r("h2",{attrs:{id:"shim进程与runc进程之间"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#shim进程与runc进程之间"}},[e._v("#")]),e._v(" shim进程与runc进程之间")]),e._v(" "),r("p",[e._v("上文可知，shim进程创建runc子进程。")]),e._v(" "),r("h2",{attrs:{id:"runc-与-容器内第一个进程-init进程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#runc-与-容器内第一个进程-init进程"}},[e._v("#")]),e._v(" runc 与 容器内第一个进程 init进程")]),e._v(" "),r("p",[e._v("看docker创建了这么多子进程，然后到了runc我们期待的自己Dockerfile中的CMD进程就要被创建了，想想都有点小激动，然而。。。")]),e._v(" "),r("p",[e._v("runc进程启动后会去启动init进程，去创建容器，然后在容器中创建进程，那才是真正我们需要的进程")]),e._v(" "),r("p",[e._v("关于runc init进程关键看StartInitialization方法（main_unix.go）")]),e._v(" "),r("h2",{attrs:{id:"docker-containerd-ctr-与-docker-containerd"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#docker-containerd-ctr-与-docker-containerd"}},[e._v("#")]),e._v(" docker-containerd-ctr 与 docker-containerd")]),e._v(" "),r("p",[e._v("ctr 是一个containerd的client，之间通过proto rpc通信, containerd监听了unix:///run/containerd/containerd.sock。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('[root@dev-86-201 ~]# docker-containerd --help\nNAME:\n   containerd - High performance container daemon\n\nUSAGE:\n   docker-containerd [global options] command [command options] [arguments...]\n\nVERSION:\n   0.2.0 commit: 0ac3cd1be170d180b2baed755e8f0da547ceb267\n\nCOMMANDS:\n   help, h    Shows a list of commands or help for one command\n\nGLOBAL OPTIONS:\n   --debug                            enable debug output in the logs\n   --state-dir "/run/containerd"                runtime state directory\n   --metrics-interval "5m0s"                    interval for flushing metrics to the store\n   --listen, -l "unix:///run/containerd/containerd.sock"    proto://address on which the GRPC API will listen\n   --runtime, -r "runc"                        name or path of the OCI compliant runtime to use when executing containers\n   --runtime-args [--runtime-args option --runtime-args option]    specify additional runtime args\n   --shim "containerd-shim"                    Name or path of shim\n   --pprof-address                         http address to listen for pprof events\n   --start-timeout "15s"                    timeout duration for waiting on a container to start before it is killed\n   --retain-count "500"                        number of past events to keep in the event log\n   --graphite-address                         Address of graphite server\n   --help, -h                            show help\n   --version, -v                        print the version\n')])])]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('[root@dev-86-201 ~]# docker-containerd-ctr --help\nNAME:\n   ctr - High performance container daemon cli\n\nUSAGE:\n   docker-containerd-ctr [global options] command [command options] [arguments...]\n\nVERSION:\n   0.2.0 commit: 0ac3cd1be170d180b2baed755e8f0da547ceb267\n\nCOMMANDS:\n   checkpoints    list all checkpoints\n   containers    interact with running containers\n   events    receive events from the containerd daemon\n   state    get a raw dump of the containerd state\n   version    return the daemon version\n   help, h    Shows a list of commands or help for one command\n\nGLOBAL OPTIONS:\n   --debug                        enable debug output in the logs\n   --address "unix:///run/containerd/containerd.sock"    proto://address of GRPC API\n   --conn-timeout "1s"                    GRPC connection timeout\n   --help, -h                        show help\n   --version, -v                    print the version\n')])])]),r("h2",{attrs:{id:"runc-架构破析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#runc-架构破析"}},[e._v("#")]),e._v(" runc 架构破析")]),e._v(" "),r("p",[e._v("比较复杂也比较重要，所以我将单独写一篇相关的介绍 "),r("a",{attrs:{href:"http://lameleg.com/tech/runc.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("这里"),r("OutboundLink")],1)]),e._v(" "),r("h4",{attrs:{id:"使用runc直接创建容器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#使用runc直接创建容器"}},[e._v("#")]),e._v(" 使用runc直接创建容器")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("mkdir /mycontainer\ncd /mycontainer\nmkdir rootfs\ndocker export $(docker create busybox) | tar -C rootfs -xvf -\n# 生成容器的配置文件config.json\nrunc spec\nrunc run mycontainerid\n")])])]),r("h4",{attrs:{id:"容器状态文件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#容器状态文件"}},[e._v("#")]),e._v(" 容器状态文件")]),e._v(" "),r("p",[e._v("默认存在/run/runc目录下,不管是docker engine创建的容器还是通过runc直接创建的容器都会在/run/runc目录下创建一个以容器名命名的目录，下面有个state.json文件用于存储文件状态")])])}),[],!1,null,null,null);n.default=a.exports}}]);