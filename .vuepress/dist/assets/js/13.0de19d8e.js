(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{205:function(e,n,t){"use strict";t.r(n);var r=t(0),a=Object(r.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"使用client-go包访问kubernetes-crd"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用client-go包访问kubernetes-crd"}},[e._v("#")]),e._v(" 使用client-go包访问Kubernetes CRD")]),e._v(" "),t("p",[e._v("Kubernetes API服务器可通过自定义资源定义轻松扩展。但是，用client-go库访问这些资源有点麻烦，官方也没有完整的文档。如kubebuilder operator-framework都能很方便的帮助我们去创建实现一个controller，但是封装的过于好导致我们并不清楚内部是怎么调用client-go的，很多场景我们是需要自己去调用接口操作CRD的而不是在controller中去访问CRD。")]),e._v(" "),t("p",[e._v("本文非常实用，比较全比较完善的相关文档也比较难找到。")]),e._v(" "),t("p",[e._v("举个栗子：")]),e._v(" "),t("p",[e._v("我们在实现虚拟机CRD时，节点上agent需要查询虚拟机CRD，这种情况显然我们不会通过controller进行操作，此时我们就需要知道怎么直接用client-go操作CRD。\n")]),e._v(" "),t("h2",{attrs:{id:"创建crd"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#创建crd"}},[e._v("#")]),e._v(" 创建CRD")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('apiVersion: "apiextensions.k8s.io/v1beta1"\nkind: "CustomResourceDefinition"\nmetadata:\n  name: "projects.example.sealyun.com"\nspec:\n  group: "example.sealyun.com"\n  version: "v1alpha1"\n  scope: "Namespaced"\n  names:\n    plural: "projects"\n    singular: "project"\n    kind: "Project"\n  validation:\n    openAPIV3Schema:\n      required: ["spec"]\n      properties:\n        spec:\n          required: ["replicas"]\n          properties:\n            replicas:\n              type: "integer"\n              minimum: 1\n')])])]),t("p",[e._v("这个可以使用kubebuilder或者operator-framework生成, 自己写太累")]),e._v(" "),t("p",[e._v("要定义自定义资源定义，您需要考虑API组名称（在本例中example.sealyun.com）。按照惯例，这通常是您控制的域的域名（例如，您组织的域），以防止命名冲突。然后CRD的名称遵循模式"),t("plural-resource-name",[e._v("."),t("api-group-name",[e._v("，因此在这种情况下projects.example.sealyun.com。")])],1)],1),e._v(" "),t("p",[e._v("通常，您希望根据特定架构验证用户在自定义资源中存储的数据。这就是spec.validation.openAPIV3Schema它的用途：它包含一个描述资源应具有的格式的JSON模式。")]),e._v(" "),t("p",[e._v("使用kubectl创建资源定义, 如果用kubebuilder可以直接make && make deploy：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('> kubectl apply -f projects-crd.yaml\ncustomresourcedefinition "projects.example.sealyun.com" created\n')])])]),t("p",[e._v("可以创建此新资源类型的实例:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('apiVersion: "example.sealyun.com/v1alpha1"\nkind: "Project"\nmetadata:\n  name: "example-project"\n  namespace: "default"\nspec:\n  replicas: 1\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('> kubectl apply -f project.yaml\nproject "example-project" created\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("> kubectl get projects\nNAME               AGE\nexample-project    2m\n")])])]),t("h1",{attrs:{id:"创建golang客户端"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#创建golang客户端"}},[e._v("#")]),e._v(" 创建Golang客户端")]),e._v(" "),t("p",[e._v("接下来，我们将使用client-go包来访问这些自定义资源。")]),e._v(" "),t("blockquote",[t("p",[e._v("定义类型")])]),e._v(" "),t("p",[e._v("kubebuilder等都会自动为您生成，我这里为了讲清楚所有的东西也加上这块的相关说明")]),e._v(" "),t("p",[e._v("首先定义自定义资源的类型。通过API组版本组织这些类型是一个很好的做法; 例如，api/types/v1alpha1/project.go：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('package v1alpha1\n\nimport metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"\n\ntype ProjectSpec struct {\n    Replicas int `json:"replicas"`\n}\n\ntype Project struct {\n\tmetav1.TypeMeta   `json:",inline"`\n\tmetav1.ObjectMeta `json:"metadata,omitempty"`\n\n    Spec ProjectSpec `json:"spec"`\n}\n\ntype ProjectList struct {\n\tmetav1.TypeMeta `json:",inline"`\n\tmetav1.ListMeta `json:"metadata,omitempty"`\n\n\tItems []Project `json:"items"`\n}\n')])])]),t("p",[e._v("该metav1.ObjectMeta类型包含了典型metadata的属性")]),e._v(" "),t("blockquote",[t("p",[e._v("定义DeepCopy方法")])]),e._v(" "),t("p",[e._v("Kubernetes API（在本例中为Project和ProjectList）提供的每种类型都需要实现该k8s.io/apimachinery/pkg/runtime.Object接口。该接口定义了两种方法GetObjectKind()和DeepCopyObject()。第一种方法已经由嵌入式metav1.TypeMeta结构提供; 第二个你必须自己实现。")]),e._v(" "),t("p",[e._v("该DeepCopyObject方法旨在生成对象的深层副本。由于这涉及许多样板代码，因此很多工具通常会自动生成这些方法。为了本文的目的，我们将手动完成。继续向deepcopy.go同一个包添加第二个文件：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('package v1alpha1\n\nimport "k8s.io/apimachinery/pkg/runtime"\n\n// DeepCopyInto copies all properties of this object into another object of the\n// same type that is provided as a pointer.\nfunc (in *Project) DeepCopyInto(out *Project) {\n    out.TypeMeta = in.TypeMeta\n    out.ObjectMeta = in.ObjectMeta\n    out.Spec = ProjectSpec{\n        Replicas: in.Spec.Replicas,\n    }\n}\n\n// DeepCopyObject returns a generically typed copy of an object\nfunc (in *Project) DeepCopyObject() runtime.Object {\n    out := Project{}\n    in.DeepCopyInto(&out)\n\n    return &out\n}\n\n// DeepCopyObject returns a generically typed copy of an object\nfunc (in *ProjectList) DeepCopyObject() runtime.Object {\n    out := ProjectList{}\n    out.TypeMeta = in.TypeMeta\n    out.ListMeta = in.ListMeta\n\n    if in.Items != nil {\n        out.Items = make([]Project, len(in.Items))\n        for i := range in.Items {\n            in.Items[i].DeepCopyInto(&out.Items[i])\n        }\n    }\n\n    return &out\n}\n')])])]),t("blockquote",[t("p",[e._v("注册类型")])]),e._v(" "),t("p",[e._v("接下来，您需要使客户端库知道新类型。允许客户端在与API服务器通信时自动处理新类型。")]),e._v(" "),t("p",[e._v("为此，register.go请在包中添加一个新文件：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('package v1alpha1\n\nimport (\n    metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"\n    "k8s.io/apimachinery/pkg/runtime"\n    "k8s.io/apimachinery/pkg/runtime/schema"\n)\n\nconst GroupName = "example.sealyun.com"\nconst GroupVersion = "v1alpha1"\n\nvar SchemeGroupVersion = schema.GroupVersion{Group: GroupName, Version: GroupVersion}\n\nvar (\n    SchemeBuilder = runtime.NewSchemeBuilder(addKnownTypes)\n    AddToScheme   = SchemeBuilder.AddToScheme\n)\n\nfunc addKnownTypes(scheme *runtime.Scheme) error {\n    scheme.AddKnownTypes(SchemeGroupVersion,\n        &Project{},\n        &ProjectList{},\n    )\n\n    metav1.AddToGroupVersion(scheme, SchemeGroupVersion)\n    return nil\n}\n')])])]),t("p",[e._v("此代码实际上并没有做任何事情（除了创建新runtime.SchemeBuilder实例）。重要的部分是AddToScheme函数，它是runtime.SchemeBuilder中创建的类型。一旦Kubernetes客户端初始化为注册您的类型，您可以稍后从客户端代码的任何部分调用此函数。")]),e._v(" "),t("blockquote",[t("p",[e._v("构建HTTP客户端")])]),e._v(" "),t("p",[e._v("在定义类型并添加方法以在全局方案构建器中注册它们之后，您现在可以创建能够加载自定义资源的HTTP客户端。")]),e._v(" "),t("p",[e._v("为此，将以下代码添加到包的main.go文件中：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('package main\n\nimport (\n    "flag"\n    "log"\n    "time"\n\n    "k8s.io/apimachinery/pkg/runtime/schema"\n    "k8s.io/apimachinery/pkg/runtime/serializer"\n\n    "github.com/martin-helmich/kubernetes-crd-example/api/types/v1alpha1"\n    "k8s.io/client-go/kubernetes/scheme"\n    "k8s.io/client-go/rest"\n    "k8s.io/client-go/tools/clientcmd"\n)\n\nvar kubeconfig string\n\nfunc init() {\n    flag.StringVar(&kubeconfig, "kubeconfig", "", "path to Kubernetes config file")\n    flag.Parse()\n}\n\nfunc main() {\n    var config *rest.Config\n    var err error\n\n    if kubeconfig == "" {\n        log.Printf("using in-cluster configuration")\n        config, err = rest.InClusterConfig()\n    } else {\n        log.Printf("using configuration from \'%s\'", kubeconfig)\n        config, err = clientcmd.BuildConfigFromFlags("", kubeconfig)\n    }\n\n    if err != nil {\n        panic(err)\n    }\n\n    v1alpha1.AddToScheme(scheme.Scheme)\n\n    crdConfig := *config\n    crdConfig.ContentConfig.GroupVersion = &schema.GroupVersion{Group: v1alpha1.GroupName, Version: v1alpha1.GroupVersion}\n    crdConfig.APIPath = "/apis"\n    crdConfig.NegotiatedSerializer = serializer.DirectCodecFactory{CodecFactory: scheme.Codecs}\n    crdConfig.UserAgent = rest.DefaultKubernetesUserAgent()\n\n    exampleRestClient, err := rest.UnversionedRESTClientFor(&crdConfig)\n    if err != nil {\n        panic(err)\n    }\n}\n')])])]),t("p",[e._v("您现在可以使用第exampleRestClient中创建的内容来查询example.sealyun.com/v1alpha1API组中的所有自定义资源。示例可能如下所示：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('result := v1alpha1.ProjectList{}\nerr := exampleRestClient.\n    Get().\n    Resource("projects").\n    Do().\n    Into(&result)\n')])])]),t("p",[e._v("为了以更加类型安全的方式使用您的API，通常最好将这些操作包装在您自己的客户端集中。为此，创建一个新的子包clientset/v1alpha1。首先，实现一个定义API组类型的接口，并将配置设置从您的main方法移动到该clientset的构造函数中（NewForConfig在下面的示例中）：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('package v1alpha1\n\nimport (\n    "github.com/martin-helmich/kubernetes-crd-example/api/types/v1alpha1"\n    "k8s.io/apimachinery/pkg/runtime/schema"\n    "k8s.io/apimachinery/pkg/runtime/serializer"\n    "k8s.io/client-go/kubernetes/scheme"\n    "k8s.io/client-go/rest"\n)\n\ntype ExampleV1Alpha1Interface interface {\n    Projects(namespace string) ProjectInterface \n}\n\ntype ExampleV1Alpha1Client struct {\n    restClient rest.Interface\n}\n\nfunc NewForConfig(c *rest.Config) (*ExampleV1Alpha1Client, error) {\n    config := *c\n    config.ContentConfig.GroupVersion = &schema.GroupVersion{Group: v1alpha1.GroupName, Version: v1alpha1.GroupVersion}\n    config.APIPath = "/apis"\n    config.NegotiatedSerializer = serializer.DirectCodecFactory{CodecFactory: scheme.Codecs}\n    config.UserAgent = rest.DefaultKubernetesUserAgent()\n\n    client, err := rest.RESTClientFor(&config)\n    if err != nil {\n        return nil, err\n    }\n\n    return &ExampleV1Alpha1Client{restClient: client}, nil\n}\n\nfunc (c *ExampleV1Alpha1Client) Projects(namespace string) ProjectInterface {\n    return &projectClient{\n        restClient: c.restClient,\n        ns: namespace,\n    }\n}\n')])])]),t("p",[e._v("以上是对client的封装")]),e._v(" "),t("p",[e._v("接下来，您需要实现一个特定的Project客户端集来访问自定义资源（请注意，上面的示例已经使用了我们仍需要提供的ProjectInterface和projectClient类型）。projects.go在同一个包中创建第二个文件：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('package v1alpha1\n\nimport (\n    "github.com/martin-helmich/kubernetes-crd-example/api/types/v1alpha1"\n    metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"\n    "k8s.io/apimachinery/pkg/watch"\n    "k8s.io/client-go/kubernetes/scheme"\n    "k8s.io/client-go/rest"\n)\n\ntype ProjectInterface interface {\n    List(opts metav1.ListOptions) (*v1alpha1.ProjectList, error)\n    Get(name string, options metav1.GetOptions) (*v1alpha1.Project, error)\n    Create(*v1alpha1.Project) (*v1alpha1.Project, error)\n    Watch(opts metav1.ListOptions) (watch.Interface, error)\n    // ...\n}\n\ntype projectClient struct {\n    restClient rest.Interface\n    ns         string\n}\n\nfunc (c *projectClient) List(opts metav1.ListOptions) (*v1alpha1.ProjectList, error) {\n    result := v1alpha1.ProjectList{}\n    err := c.restClient.\n        Get().\n        Namespace(c.ns).\n        Resource("projects").\n        VersionedParams(&opts, scheme.ParameterCodec).\n        Do().\n        Into(&result)\n\n    return &result, err\n}\n\nfunc (c *projectClient) Get(name string, opts metav1.GetOptions) (*v1alpha1.Project, error) {\n    result := v1alpha1.Project{}\n    err := c.restClient.\n        Get().\n        Namespace(c.ns).\n        Resource("projects").\n        Name(name).\n        VersionedParams(&opts, scheme.ParameterCodec).\n        Do().\n        Into(&result)\n\n    return &result, err\n}\n\nfunc (c *projectClient) Create(project *v1alpha1.Project) (*v1alpha1.Project, error) {\n    result := v1alpha1.Project{}\n    err := c.restClient.\n        Post().\n        Namespace(c.ns).\n        Resource("projects").\n        Body(project).\n        Do().\n        Into(&result)\n\n    return &result, err\n}\n\nfunc (c *projectClient) Watch(opts metav1.ListOptions) (watch.Interface, error) {\n    opts.Watch = true\n    return c.restClient.\n        Get().\n        Namespace(c.ns).\n        Resource("projects").\n        VersionedParams(&opts, scheme.ParameterCodec).\n        Watch()\n}\n')])])]),t("p",[e._v("上面还缺少一些Delete Update方法，照抄就行，或者参考"),t("a",{attrs:{href:"https://github.com/kubernetes/client-go/blob/master/kubernetes/typed/core/v1/pod.go",target:"_blank",rel:"noopener noreferrer"}},[e._v("pod的实现"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("再去使用就变的非常简单了：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('import clientV1alpha1 "github.com/martin-helmich/kubernetes-crd-example/clientset/v1alpha1"\n// ...\n\nfunc main() {\n    // ...\n\n    clientSet, err := clientV1alpha1.NewForConfig(config)\n    if err != nil {\n        panic(err)\n    }\n\n    projects, err := clientSet.Projects("default").List(metav1.ListOptions{})\n    if err != nil {\n        panic(err)\n    }\n\n    fmt.Printf("projects found: %+v\\n", projects)\n}\n')])])]),t("blockquote",[t("p",[e._v("创建informer")])]),e._v(" "),t("p",[e._v("构建Kubernetes operator时，通常希望能够对新创建或更新的事件进行监听。理论上，可以定期调用该List()方法并检查是否添加了新资源。")]),e._v(" "),t("p",[e._v("大多数情况通过使用初始List()初始加载资源的所有相关实例，然后使用Watch()订阅相关事件进行处理。然后，使用从informer接收的初始对象列表和更新来构建本地缓存，该缓存允许快速访问任何自定义资源，而无需每次都访问API服务器。")]),e._v(" "),t("p",[e._v("这种模式非常普遍，以至于client-go库为此提供了一个cache包：来自包的Informerk8s.io/client-go/tools/cache。您可以为自定义资源构建新的Informer，如下所示：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('package main\n\nimport (\n    "time"\n\n    "github.com/martin-helmich/kubernetes-crd-example/api/types/v1alpha1"\n    client_v1alpha1 "github.com/martin-helmich/kubernetes-crd-example/clientset/v1alpha1"\n    metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"\n    "k8s.io/apimachinery/pkg/runtime"\n    "k8s.io/apimachinery/pkg/util/wait"\n    "k8s.io/apimachinery/pkg/watch"\n    "k8s.io/client-go/tools/cache"\n)\n\nfunc WatchResources(clientSet client_v1alpha1.ExampleV1Alpha1Interface) cache.Store {\n    projectStore, projectController := cache.NewInformer(\n        &cache.ListWatch{\n            ListFunc: func(lo metav1.ListOptions) (result runtime.Object, err error) {\n                return clientSet.Projects("some-namespace").List(lo)\n            },\n            WatchFunc: func(lo metav1.ListOptions) (watch.Interface, error) {\n                return clientSet.Projects("some-namespace").Watch(lo)\n            },\n        },\n        &v1alpha1.Project{},\n        1*time.Minute,\n        cache.ResourceEventHandlerFuncs{},\n    )\n\n    go projectController.Run(wait.NeverStop)\n    return projectStore\n}\n')])])]),t("p",[e._v("该NewInformer方法返回两个对象：第二个返回值，控制器控制List()和Watch()调用并填充第一个返回值，Store缓存监听到的一些信息。\n您现在可以使用store轻松访问CRD，列出所有CRD或通过名称访问它们。store函数返回interface{}类型，因此您必须将它们强制转换回CRD类型：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('store := WatchResource(clientSet)\nproject := store.GetByKey("some-namespace/some-project").(*v1alpha1.Project)\n')])])]),t("p",[e._v("如此很多情况下就不需要再去调用apiserver了，给apiserver减轻压力.")]),e._v(" "),t("h1",{attrs:{id:"在kubebuilder中进行访问"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#在kubebuilder中进行访问"}},[e._v("#")]),e._v(" 在kubebuilder中进行访问")]),e._v(" "),t("p",[e._v("通过获取manager中的reader, 但是这里只能读不能写，写的话需要mgr.GetClient() 但是这个就必须是长时间运行的")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://github.com/kubernetes-sigs/kubebuilder/issues/947",target:"_blank",rel:"noopener noreferrer"}},[e._v("更多详情"),t("OutboundLink")],1),e._v(" "),t("a",{attrs:{href:"https://github.com/kubernetes-sigs/controller-runtime/pull/609",target:"_blank",rel:"noopener noreferrer"}},[e._v("想加入apiclient功能PR"),t("OutboundLink")],1)]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('package main\n\nimport (\n\t"context"\n\t"fmt"\n\t"os"\n\n\t"k8s.io/apimachinery/pkg/types"\n\n\tv1 "github.com/fanux/sealvm/api/v1"\n\t"github.com/prometheus/common/log"\n\t"k8s.io/apimachinery/pkg/runtime"\n\tctrl "sigs.k8s.io/controller-runtime"\n\tclientgoscheme "k8s.io/client-go/kubernetes/scheme"\n)\n\nvar scheme = runtime.NewScheme()\n\nfunc init() {\n\tv1.AddToScheme(scheme)\n\tclientgoscheme.AddToScheme(scheme)\n}\n\nfunc main() {\n\tmgr, err := ctrl.NewManager(ctrl.GetConfigOrDie(), ctrl.Options{\n\t\tScheme: scheme,\n\t})\n\tif err != nil {\n\t\tos.Exit(1)\n\t}\n\tclient := mgr.GetAPIReader() // 如果是长时间运行用mgr.GetClient()\n\tctx := context.Background()\n\tname := types.NamespacedName{Namespace: "default", Name: "virtulmachine-sample"}\n\n\tvm := &v1.VirtulMachine{}\n\tif err := client.Get(ctx, name, vm); err != nil {\n\t\tlog.Error(err, "unable to fetch vm")\n\t} else {\n\t\tfmt.Println(vm.Spec.CPU, vm.Spec.Memory, vm)\n\t}\n}\n')])])]),t("p",[e._v("推荐做法，直接调用client:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('package main\n\nimport (\n\t"context"\n\t"fmt"\n\t"sigs.k8s.io/controller-runtime/pkg/client"\n\n\t"k8s.io/apimachinery/pkg/types"\n\n\tv1 "github.com/fanux/sealvm/api/v1"\n\t"github.com/prometheus/common/log"\n\t"k8s.io/apimachinery/pkg/runtime"\n\tctrl "sigs.k8s.io/controller-runtime"\n\n\tclientgoscheme "k8s.io/client-go/kubernetes/scheme"\n)\n\nvar scheme = runtime.NewScheme()\n\nfunc init() {\n\tv1.AddToScheme(scheme)\n\tclientgoscheme.AddToScheme(scheme)\n}\n\nfunc getClient() (client.Client, error){\n\tconfig := ctrl.GetConfigOrDie()\n\tif config == nil {\n\t\treturn nil, fmt.Errorf("config is nil")\n\t}\n\toptions := ctrl.Options{Scheme:scheme}\n\t// Set default values for options fields\n\t//options = setOptionsDefaults(options)\n\t//mapper, err := options.MapperProvider(config)\n\t//if err != nil {\n\t//\tlog.Error(err, "Failed to get API Group-Resources")\n\t//\treturn nil, err\n\t//}\n\n\tclient, err := client.New(config, client.Options{Scheme: options.Scheme})\n\tif err !=nil {\n\t\treturn nil, err\n\t}\n\treturn client,nil\n}\n\nfunc main() {\n\tclient,err := getClient()\n\tif err != nil {\n\t\tfmt.Println("client is nil",err)\n\t\treturn\n\t}\n\n\tctx := context.Background()\n\tname := types.NamespacedName{Namespace: "default", Name: "virtulmachine-sample"}\n\n\tvm := &v1.VirtulMachine{}\n\tif err = client.Get(ctx, name, vm); err != nil {\n\t\tlog.Error(err, "unable to fetch vm")\n\t} else {\n\t\tfmt.Println(vm.Spec.CPU, vm.Spec.Memory, vm)\n\t}\n}\n')])])]),t("h1",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),t("p",[e._v("虽然现在很多工具给我们写CRD controller带来了极大的便捷，但是对于client-go这些基本的使用还是非常必要的，而官方client-go的开发文档和事例真的是少之又少，基本仅包含非常基本的操作。")]),e._v(" "),t("p",[e._v("还有一个dynamic client的方式也可以用来访问自定义CRD，但是文中的方式会更优雅更清晰更适合工程化。")])])}),[],!1,null,null,null);n.default=a.exports}}]);