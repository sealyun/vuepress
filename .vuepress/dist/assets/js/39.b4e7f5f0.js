(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{240:function(e,t,a){"use strict";a.r(t);var r=a(0),n=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"kubernetes源码分析之kube-scheduler-从代码看原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#kubernetes源码分析之kube-scheduler-从代码看原理"}},[e._v("#")]),e._v(" kubernetes源码分析之kube-scheduler - 从代码看原理")]),e._v(" "),a("h2",{attrs:{id:"关于源码编译"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#关于源码编译"}},[e._v("#")]),e._v(" 关于源码编译")]),e._v(" "),a("p",[e._v("我嫌弃官方提供的编译脚本太麻烦，所以用了更简单粗暴的方式编译k8s代码，当然官方脚本在编译所有项目或者夸平台编译以及realse时还是挺有用的。")]),e._v(" "),a("p",[e._v("在容器中编译：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("docker run -v /work/src/k8s.io/kubernetes:/go/src/k8s.io/kubernetes golang:1.11.2 bash\n")])])]),a("p",[e._v("在容器中可以保证环境干净")]),e._v(" "),a("p",[e._v("进入bash后直接进入kube-scheduler的主目录编译即可\n")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("cd cmd/kube-scheduler && go build\n")])])]),a("p",[e._v("二进制就产生了。。。")]),e._v(" "),a("h3",{attrs:{id:"源码编译接入ci-cd"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#源码编译接入ci-cd"}},[e._v("#")]),e._v(" 源码编译接入CI/CD")]),e._v(" "),a("p",[e._v("作为高端玩家，自动化是必须的，因为服务器性能更好，用CI/CD编译更快，这里分享一下我的一些配置:")]),e._v(" "),a("ol",[a("li",[e._v("我把vendor打到编译的基础镜像里了，因为vendor大而且不经常更新")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("$ cat Dockerfile-build1.12.2\nFROM golang:1.11.2\nCOPY vendor/ /vendor\n")])])]),a("p",[e._v("然后代码里的vendor就可以删了")]),e._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[e._v(".drone.yml")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("workspace:\n  base: /go/src/k8s.io\n  path: kubernetes\n\npipeline:\n    build:\n        image: fanux/kubernetes-build:1.12.2-beta.3\n        commands:\n           - make all WHAT=cmd/kube-kubescheduler GOFLAGS=-v\n    publish:\n        image: plugins/docker\n        registry: xxx\n        username: xxx\n        password: xxx\n        email: xxx\n        repo: xxx/container/kube-scheduler\n        tags: ${DRONE_TAG=latest}\n        dockerfile: dockerfile/Dockerfile-kube-scheduler\n        insecure: true\n        when:\n            event: [push, tag]\n")])])]),a("ol",{attrs:{start:"3"}},[a("li",[e._v("Dockerfile 静态编译连基础镜像都省了")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('$ cat dockerfile/Dockerfile-kube-scheduler\nFROM scratch\nCOPY  _output/local/bin/linux/amd64/kube-scheduler /\nCMD ["/kube-scheduler"]\n')])])]),a("p",[e._v("对于kubeadm这种二进制交付的，可直接编译然后传到nexus上, 通过drone deploy事件选择是不是要编译kubeadm：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("    build_kubeadm:\n        image: fanux/kubernetes-build:1.12.2-beta.3\n        commands:\n           - make all WHAT=cmd/kube-kubeadm GOFLAGS=-v\n           - curl -v -u container:container --upload-file kubeadm http://172.16.59.153:8081/repository/kubernetes/kubeadm/\n        when:\n            event: deployment\n            enviroment: kubeadm\n")])])]),a("h3",{attrs:{id:"直接go-build的大坑"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#直接go-build的大坑"}},[e._v("#")]),e._v(" 直接go build的大坑")]),e._v(" "),a("p",[e._v("发现build完的kubeadm二进制并不能用，可能是build时选用的基础镜像的问题，也可能是没去生成一些代码导致的问题")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("[signal SIGSEGV: segmentation violation code=0x1 addr=0x63 pc=0x7f2b7f5f057c]\n\nruntime stack:\nruntime.throw(0x17c74a8, 0x2a)\n\t/usr/local/go/src/runtime/panic.go:608 +0x72\nruntime.sigpanic()\n\t/usr/local/go/src/runtime/signal_unix.go:374 +0x2f2\n")])])]),a("p",[e._v("后面再补上CD的配置")]),e._v(" "),a("p",[e._v("如此我编译scheduler代码大约40秒左右，如vendor可软连接还可节省十几秒")]),e._v(" "),a("h1",{attrs:{id:"调度器cache"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#调度器cache"}},[e._v("#")]),e._v(" 调度器cache")]),e._v(" "),a("h2",{attrs:{id:"cache状态机"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cache状态机"}},[e._v("#")]),e._v(" cache状态机")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("   +-------------------------------------------+  +----+\n   |                            Add            |  |    |\n   |                                           |  |    | Update\n   +      Assume                Add            v  v    |\nInitial +--------\x3e Assumed +------------+---\x3e Added <--+\n   ^                +   +               |       +\n   |                |   |               |       |\n   |                |   |           Add |       | Remove\n   |                |   |               |       |\n   |                |   |               +       |\n   +----------------+   +-----------\x3e Expired   +----\x3e Deleted\n")])])]),a("ul",[a("li",[e._v("Assume 尝试调度，会把node信息聚合到node上，如pod require多少CPU内存，那么加到node上，如果超时了需要重新减掉")]),e._v(" "),a("li",[e._v("AddPod 会检测是不是已经尝试调度了该pod，校验是否过期,如果过期了会被重新添加")]),e._v(" "),a("li",[e._v("Remove pod信息会在该节点上被清除掉")]),e._v(" "),a("li",[e._v("cache其它接口如node相关的cache接口  ADD update等")])]),e._v(" "),a("h2",{attrs:{id:"cache实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cache实现"}},[e._v("#")]),e._v(" cache实现")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("type schedulerCache struct {\n\tstop   <-chan struct{}\n\tttl    time.Duration\n\tperiod time.Duration\n\n\t// This mutex guards all fields within this cache struct.\n\tmu sync.RWMutex\n\t// a set of assumed pod keys.\n\t// The key could further be used to get an entry in podStates.\n\tassumedPods map[string]bool\n\t// a map from pod key to podState.\n\tpodStates map[string]*podState\n\tnodes     map[string]*NodeInfo\n\tnodeTree  *NodeTree\n\tpdbs      map[string]*policy.PodDisruptionBudget\n\t// A map from image name to its imageState.\n\timageStates map[string]*imageState\n}\n")])])]),a("p",[e._v("这里存储了基本调度所需要的所有信息")]),e._v(" "),a("p",[e._v("以AddPod接口为例，本质上就是把监听到的一个pod放到了cache的map里：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("cache.addPod(pod)\nps := &podState{\n\tpod: pod,\n}\ncache.podStates[key] = ps\n")])])]),a("p",[e._v("node Tree\n节点信息有这样一个结构体保存：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("type NodeTree struct {\n\ttree      map[string]*nodeArray // a map from zone (region-zone) to an array of nodes in the zone.\n\tzones     []string              // a list of all the zones in the tree (keys)\n\tzoneIndex int\n\tNumNodes  int\n\tmu        sync.RWMutex\n}\n")])])]),a("p",[e._v("cache 运行时会循环清理过期的assume pod")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("func (cache *schedulerCache) run() {\n\tgo wait.Until(cache.cleanupExpiredAssumedPods, cache.period, cache.stop)\n}\n")])])]),a("h1",{attrs:{id:"scheduler"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#scheduler"}},[e._v("#")]),e._v(" scheduler")]),e._v(" "),a("p",[e._v("scheduler里面最重要的两个东西：cache 和调度算法")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("type Scheduler struct {\n\tconfig *Config  -------\x3e SchedulerCache\n                       |\n                       +---\x3e Algorithm\n}\n")])])]),a("p",[e._v("等cache更新好了，调度器就是调度一个pod:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("func (sched *Scheduler) Run() {\n\tif !sched.config.WaitForCacheSync() {\n\t\treturn\n\t}\n\n\tgo wait.Until(sched.scheduleOne, 0, sched.config.StopEverything)\n}\n")])])]),a("p",[e._v("核心逻辑来了：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("   +-------------+\n   | 获取一个pod |\n   +-------------+\n          |\n   +-----------------------------------------------------------------------------------+\n   | 如果pod的DeletionTimestamp 存在就不用进行调度, kubelet发现这个字段会直接去删除pod |\n   +-----------------------------------------------------------------------------------+\n          |\n   +-----------------------------------------+\n   | 选一个suggestedHost，可理解为合适的节点 |\n   +-----------------------------------------+\n          |_____________选不到就进入强占的逻辑，与我当初写swarm调度器逻辑类似\n          |\n   +--------------------------------------------------------------------------------+\n   | 虽然还没真调度到node上，但是告诉cache pod已经被调度到node上了，变成assume pod  |\n   | 这里面会先检查volumes                                                          |\n   | 然后：err = sched.assume(assumedPod, suggestedHost) 假设pod被调度到node上了    |\n   +--------------------------------------------------------------------------------+\n          |\n   +---------------------------+\n   | 异步的bind这个pod到node上 |\n   | 先bind volume             |\n   | bind pod                  |\n   +---------------------------+\n          |\n   +----------------+\n   | 暴露一些metric |\n   +----------------+\n")])])]),a("h2",{attrs:{id:"bind动作："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bind动作："}},[e._v("#")]),e._v(" bind动作：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('err := sched.bind(assumedPod, &v1.Binding{\n\tObjectMeta: metav1.ObjectMeta{Namespace: assumedPod.Namespace, Name: assumedPod.Name, UID: assumedPod.UID},\n\tTarget: v1.ObjectReference{\n\t\tKind: "Node",\n\t\tName: suggestedHost,\n\t},\n})\n')])])]),a("p",[e._v("先去bind pod，然后告诉cache bind结束")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("err := sched.config.GetBinder(assumed).Bind(b)\nif err := sched.config.SchedulerCache.FinishBinding(assumed); \n")])])]),a("h3",{attrs:{id:"bind-流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bind-流程"}},[e._v("#")]),e._v(" bind 流程")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("   +----------------+\n   | GetBinder.Bind\n   +----------------+\n       |\n   +-------------------------------------+\n   | 告诉cache bind完成 FinishBinding接口\n   +-------------------------------------+\n       |\n   +-----------------------------------------------------+\n   | 失败了就ForgetPod, 更新一下pod状态为 BindingRejected\n   +-----------------------------------------------------+\n")])])]),a("h3",{attrs:{id:"bind-实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bind-实现"}},[e._v("#")]),e._v(" bind 实现")]),e._v(" "),a("p",[e._v("最终就是调用了apiserver bind接口:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('func (b *binder) Bind(binding *v1.Binding) error {\n\tglog.V(3).Infof("Attempting to bind %v to %v", binding.Name, binding.Target.Name)\n\treturn b.Client.CoreV1().Pods(binding.Namespace).Bind(binding)\n}\n')])])]),a("h2",{attrs:{id:"调度算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#调度算法"}},[e._v("#")]),e._v(" 调度算法")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("▾ algorithm/\n  ▸ predicates/  预选\n  ▸ priorities/  优选\n")])])]),a("p",[e._v("现在最重要的就是选节点的实现")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("suggestedHost, err := sched.schedule(pod)\n")])])]),a("p",[e._v("也就是调度算法的实现：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("type ScheduleAlgorithm interface {\n    // 传入pod 节点列表，返回一下合适的节点\n\tSchedule(*v1.Pod, NodeLister) (selectedMachine string, err error)\n    // 资源抢占用的\n\tPreempt(*v1.Pod, NodeLister, error) (selectedNode *v1.Node, preemptedPods []*v1.Pod, cleanupNominatedPods []*v1.Pod, err error)\n\n    // 预选函数集，\n\tPredicates() map[string]FitPredicate\n                                |                              这一个节点适合不适合调度这个pod，不适合的话返回原因\n                                +-------type FitPredicate func(pod *v1.Pod, meta PredicateMetadata, nodeInfo *schedulercache.NodeInfo) (bool, []PredicateFailureReason, error)\n    // 返回优选配置,最重要两个函数 map 和 reduce\n\tPrioritizers() []PriorityConfig\n                         |____________PriorityMapFunction 计算 节点的优先级\n                         |____________PriorityReduceFunction 根据map的结果计算所有node的最终得分\n                         |____________PriorityFunction 废弃\n}\n")])])]),a("p",[e._v("调度算法可以通过两种方式生成：")]),e._v(" "),a("ul",[a("li",[e._v("Provider 默认方式, 通用调度器")]),e._v(" "),a("li",[e._v("Policy   策略方式, 特殊调度器")])]),e._v(" "),a("p",[e._v("最终new了一个scheduler:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("priorityConfigs, err := c.GetPriorityFunctionConfigs(priorityKeys)\npriorityMetaProducer, err := c.GetPriorityMetadataProducer()\npredicateMetaProducer, err := c.GetPredicateMetadataProducer()\n                                              |\nalgo := core.NewGenericScheduler(             |\n\tc.schedulerCache,                         |\n\tc.equivalencePodCache,                    V\n\tc.podQueue,\n\tpredicateFuncs,   ============> 这里面把预选优选函数都注入进来了\n\tpredicateMetaProducer,\n\tpriorityConfigs,\n\tpriorityMetaProducer,\n\textenders,\n\tc.volumeBinder,\n\tc.pVCLister,\n\tc.alwaysCheckAllPredicates,\n\tc.disablePreemption,\n\tc.percentageOfNodesToScore,\n)\n\n\ntype genericScheduler struct {\n\tcache                    schedulercache.Cache\n\tequivalenceCache         *equivalence.Cache\n\tschedulingQueue          SchedulingQueue\n\tpredicates               map[string]algorithm.FitPredicate\n\tpriorityMetaProducer     algorithm.PriorityMetadataProducer\n\tpredicateMetaProducer    algorithm.PredicateMetadataProducer\n\tprioritizers             []algorithm.PriorityConfig\n\textenders                []algorithm.SchedulerExtender\n\tlastNodeIndex            uint64\n\talwaysCheckAllPredicates bool\n\tcachedNodeInfoMap        map[string]*schedulercache.NodeInfo\n\tvolumeBinder             *volumebinder.VolumeBinder\n\tpvcLister                corelisters.PersistentVolumeClaimLister\n\tdisablePreemption        bool\n\tpercentageOfNodesToScore int32\n}\n")])])]),a("p",[e._v("这个scheduler实现了ScheduleAlgorithm中定义的接口")]),e._v(" "),a("p",[e._v("Schedule 流程：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("   +------------------------------------+\n   | trace记录一下，要开始调度哪个pod了 | \n   +------------------------------------+\n          |\n   +-----------------------------------------------+\n   | pod基本检查，这里主要检查卷和delete timestamp |\n   +-----------------------------------------------+\n          |\n   +----------------------------------------+\n   | 获取node列表, 更新cache的node info map |\n   +----------------------------------------+\n          |\n   +----------------------------------------------+\n   | 预选，返回合适的节点列表和预选失败节点的原因 |\n   +----------------------------------------------+\n          |\n   +----------------------------------------------------------+\n   | 优选，                                                   |\n   | 如果预选结果只有一个节点，那么直接使用之，不需要进行优选 |\n   | 否则进行优选过程                                         |\n   +----------------------------------------------------------+\n          |\n   +------------------------------------+\n   | 在优选结果列表中选择得分最高的节点 |\n   +------------------------------------+\n")])])]),a("h3",{attrs:{id:"预选"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#预选"}},[e._v("#")]),e._v(" 预选")]),e._v(" "),a("p",[e._v("主要分成两块")]),e._v(" "),a("ul",[a("li",[e._v("预选, 检查该节点符合不符合")]),e._v(" "),a("li",[e._v("执行extender, 自定义调度器扩展，官方实现了HTTP extender 把预选结果发给用户，用户再去过滤")])]),e._v(" "),a("p",[e._v("podFitOnNode: 判断这个节点是不是适合这个pod调度")]),e._v(" "),a("p",[e._v("这里插播一个小知识，调度器里有个Ecache:")]),e._v(" "),a("p",[e._v("Equivalence Class目前是用来在Kubernetes Scheduler加速Predicate，提升Scheduler的吞吐性能。\nKubernetes scheduler及时维护着Equivalence Cache的数据，当某些情况发生时（比如delete node、bind pod等事件），\n需要立刻invalid相关的Equivalence Cache中的缓存数据。")]),e._v(" "),a("p",[e._v("一个Equivalence Class是用来定义一组具有相同Requirements和Constraints的Pods的相关信息的集合，\n在Scheduler进行Predicate阶段时可以只需对Equivalence Class中一个Pod进行Predicate，并把Predicate的结果放到\nEquivalence Cache中以供该Equivalence Class中其他Pods（成为Equivalent Pods）重用该结果。只有当Equivalence Cache\n中没有可以重用的Predicate Result才会进行正常的Predicate流程。")]),e._v(" "),a("p",[e._v("ecache这块后续可以深入讨论，本文更多关注核心架构与流程")]),e._v(" "),a("p",[e._v("所以这块就比较简单了, 把所有的预选函数执行行一遍")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("先排序 predicates.Ordering() \nif predicate, exist := predicateFuncs[predicateKey]; exist {\n\t\tfit, reasons, err = predicate(pod, metaToUse, nodeInfoToUse)\n")])])]),a("p",[e._v("顺序是这样的：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("\tpredicatesOrdering = []string{CheckNodeConditionPred, CheckNodeUnschedulablePred,\n\t\tGeneralPred, HostNamePred, PodFitsHostPortsPred,\n\t\tMatchNodeSelectorPred, PodFitsResourcesPred, NoDiskConflictPred,\n\t\tPodToleratesNodeTaintsPred, PodToleratesNodeNoExecuteTaintsPred, CheckNodeLabelPresencePred,\n\t\tCheckServiceAffinityPred, MaxEBSVolumeCountPred, MaxGCEPDVolumeCountPred, MaxCSIVolumeCountPred,\n\t\tMaxAzureDiskVolumeCountPred, CheckVolumeBindingPred, NoVolumeZoneConflictPred,\n\t\tCheckNodeMemoryPressurePred, CheckNodePIDPressurePred, CheckNodeDiskPressurePred, MatchInterPodAffinityPred}\n")])])]),a("p",[e._v("这些预选函数是存在一个map里的，key是一个string，value就是一个预选函数, 再回头去看注册map的逻辑")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("predicateFuncs, err := c.GetPredicates(predicateKeys)\n")])])]),a("p",[e._v("pkg/scheduler/algorithmprovider/defaults/defaults.go 里面会对这些函数进行注册,如：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("factory.RegisterFitPredicate(predicates.NoDiskConflictPred, predicates.NoDiskConflict),\nfactory.RegisterFitPredicate(predicates.GeneralPred, predicates.GeneralPredicates),\nfactory.RegisterFitPredicate(predicates.CheckNodeMemoryPressurePred, predicates.CheckNodeMemoryPressurePredicate),\nfactory.RegisterFitPredicate(predicates.CheckNodeDiskPressurePred, predicates.CheckNodeDiskPressurePredicate),\nfactory.RegisterFitPredicate(predicates.CheckNodePIDPressurePred, predicates.CheckNodePIDPressurePredicate),\n")])])]),a("p",[e._v("然后直接在init函数里调用注册逻辑")]),e._v(" "),a("h3",{attrs:{id:"优选"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优选"}},[e._v("#")]),e._v(" 优选")]),e._v(" "),a("p",[e._v("PrioritizeNodes 优选大概可分为三个步骤:")]),e._v(" "),a("ul",[a("li",[e._v("Map      计算单个节点,优先级")]),e._v(" "),a("li",[e._v("Reduce   计算每个节点结果聚合,计算所有节点的最终得分")]),e._v(" "),a("li",[e._v("Extender 与预选差不多")])]),e._v(" "),a("p",[e._v("优选函数同理也是注册进去的, 不再赘述")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('factory.RegisterPriorityFunction2("LeastRequestedPriority", priorities.LeastRequestedPriorityMap, nil, 1),\n// Prioritizes nodes to help achieve balanced resource usage\nfactory.RegisterPriorityFunction2("BalancedResourceAllocation", priorities.BalancedResourceAllocationMap, nil, 1),\n')])])]),a("p",[e._v("这里注册时注册两个，一个map函数一个reduce函数，为了更好的理解mapreduce，去看一个实现")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('factory.RegisterPriorityFunction2("NodeAffinityPriority", priorities.CalculateNodeAffinityPriorityMap, priorities.CalculateNodeAffinityPriorityReduce, 1)\n')])])]),a("h3",{attrs:{id:"node-affinity-map-reduce"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#node-affinity-map-reduce"}},[e._v("#")]),e._v(" node Affinity map reduce")]),e._v(" "),a("p",[e._v("map 核心逻辑, 比较容易理解:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("如果满足节点亲和，积分加权重\ncount += preferredSchedulingTerm.Weight\n\nreturn schedulerapi.HostPriority{\n\tHost:  node.Name,\n\tScore: int(count),  # 算出积分\n}, nil\n")])])]),a("p",[e._v("reduce:\n一个节点会走很多个map，每个map会产生一个分值，如node affinity产生一个，pod affinity再产生一个，所以node和分值是一对多的关系")]),e._v(" "),a("p",[e._v("去掉reverse的逻辑（分值越高优先级越低）")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var maxCount int\nfor i := range result {\n\tif result[i].Score > maxCount {\n\t\tmaxCount = result[i].Score  # 所有分值里的最大值\n\t}\n}\n\nfor i := range result {\n\tscore := result[i].Score\n\tscore = maxPriority * score / maxCount  # 分值乘以最大优先级是maxPriority = 10，除以最大值赋值给分值 这里是做了归一化处理;\n\tresult[i].Score = score\n}\n")])])]),a("p",[e._v("这里做了归一化处理后分值就变成[0,maxPriority]之间了")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("for i := range priorityConfigs {\n\tif priorityConfigs[i].Function != nil {\n\t\tcontinue\n\t}\n\tresults[i][index], err = priorityConfigs[i].Map(pod, meta, nodeInfo)\n\tif err != nil {\n\t\tappendError(err)\n\t\tresults[i][index].Host = nodes[index].Name\n\t}\n}\n\nerr := config.Reduce(pod, meta, nodeNameToInfo, results[index]); \n")])])]),a("p",[e._v("看这里有个results,对理解很重要，是一个二维数组：")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("xxx")]),e._v(" "),a("th",[e._v("node1")]),e._v(" "),a("th",[e._v("node2")]),e._v(" "),a("th",[e._v("node3")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("nodeaffinity")]),e._v(" "),a("td",[e._v("1分")]),e._v(" "),a("td",[e._v("2分")]),e._v(" "),a("td",[e._v("1分")])]),e._v(" "),a("tr",[a("td",[e._v("pod affinity")]),e._v(" "),a("td",[e._v("1分")]),e._v(" "),a("td",[e._v("3分")]),e._v(" "),a("td",[e._v("6分")])]),e._v(" "),a("tr",[a("td",[e._v("...")]),e._v(" "),a("td",[e._v("...")]),e._v(" "),a("td",[e._v("...")]),e._v(" "),a("td",[e._v("...")])])])]),e._v(" "),a("p",[e._v("这样reduce时取一行，其实也就是处理所有节点的某项得分")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("result[i].Score += results[j][i].Score * priorityConfigs[j].Weight  (二维变一维)\n\n")])])]),a("p",[e._v("reduce完最终这个节点的得分就等于这个节点各项得分乘以该项权重的和,最后排序选最高分 (一维变0纬)")]),e._v(" "),a("h1",{attrs:{id:"调度队列-schedulingqueue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#调度队列-schedulingqueue"}},[e._v("#")]),e._v(" 调度队列 SchedulingQueue")]),e._v(" "),a("p",[e._v("scheduler配置里有一个"),a("code",[e._v("NextPod")]),e._v(" 方法，获取一个pod，并进行调度：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("pod := sched.config.NextPod()\n")])])]),a("p",[e._v("配置文件在这里初始化：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("pkg/scheduler/factory/factory.go\nNextPod: func() *v1.Pod {\n\treturn c.getNextPod()\n},\n\nfunc (c *configFactory) getNextPod() *v1.Pod {\n\tpod, err := c.podQueue.Pop()\n\tif err == nil {\n\t\treturn pod\n\t}\n...\n}\n")])])]),a("p",[e._v("队列接口：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("type SchedulingQueue interface {\n\tAdd(pod *v1.Pod) error\n\tAddIfNotPresent(pod *v1.Pod) error\n\tAddUnschedulableIfNotPresent(pod *v1.Pod) error\n\tPop() (*v1.Pod, error)\n\tUpdate(oldPod, newPod *v1.Pod) error\n\tDelete(pod *v1.Pod) error\n\tMoveAllToActiveQueue()\n\tAssignedPodAdded(pod *v1.Pod)\n\tAssignedPodUpdated(pod *v1.Pod)\n\tWaitingPodsForNode(nodeName string) []*v1.Pod\n\tWaitingPods() []*v1.Pod\n}\n")])])]),a("p",[e._v("给了两种实现，优先级队列和FIFO ：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("func NewSchedulingQueue() SchedulingQueue {\n\tif util.PodPriorityEnabled() {\n\t\treturn NewPriorityQueue()  # 基于堆排序实现，根据优先级排序\n\t}\n\treturn NewFIFO() # 简单的先进先出\n}\n")])])]),a("p",[e._v("队列实现比较简单，不做深入分析, 更重要的是关注队列，调度器，cache之间的关系:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('AddFunc:    c.addPodToCache,\nUpdateFunc: c.updatePodInCache,\nDeleteFunc: c.deletePodFromCache,\n            | informer监听,了pod创建事件之后往cache和队列里都更新了\n            V \nif err := c.schedulerCache.AddPod(pod); err != nil {\n\tglog.Errorf("scheduler cache AddPod failed: %v", err)\n}\n\nc.podQueue.AssignedPodAdded(pod)\n')])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("+------------+ ADD   +-------------+   POP  +-----------+\n| informer   |------\x3e|  sche Queue |-------\x3e| scheduler |\n+------------+   |   +-------------+        +----^------+\n                 +--\x3e+-------------+             |\n                     | sche cache  |<------------+\n                     +-------------+\n")])])]),a("h1",{attrs:{id:"extender"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#extender"}},[e._v("#")]),e._v(" Extender")]),e._v(" "),a("h2",{attrs:{id:"调度器扩展"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#调度器扩展"}},[e._v("#")]),e._v(" 调度器扩展")]),e._v(" "),a("p",[e._v("定制化调度器有三种方式：")]),e._v(" "),a("ul",[a("li",[e._v("改scheduler代码重新编译 - 没啥可讨论")]),e._v(" "),a("li",[e._v("重写调度器，调度时选择调度器 - 比较简单，问题是没法与默认调度器共同作用")]),e._v(" "),a("li",[e._v("写调度器扩展（extender）让k8s调度完了 把符合的节点扔给你 你再去过滤和优选 - 重点讨论，新版本做了一些升级，老的方式可能都无用了 "),a("a",{attrs:{href:"https://github.com/kubernetes/community/blob/master/contributors/design-proposals/scheduling/scheduler_extender.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("资料"),a("OutboundLink")],1)]),e._v(" "),a("li",[e._v("这里有个调度器扩展"),a("a",{attrs:{href:"https://github.com/everpeace/k8s-scheduler-extender-example",target:"_blank",rel:"noopener noreferrer"}},[e._v("事例"),a("OutboundLink")],1)])]),e._v(" "),a("p",[e._v("目前第三点资料非常少，很多细节需要在代码里找到答案，带着问题看代码效果更好。")]),e._v(" "),a("h2",{attrs:{id:"extender接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#extender接口"}},[e._v("#")]),e._v(" Extender接口")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("+----------------------------------+       +----------+\n| kube-scheduler -> extender client|------\x3e| extender | (你需要开发的扩展，单独的进程)\n+----------------------------------+       +----------+\n")])])]),a("p",[e._v("这个接口是kube-scheduler实现的，下面会介绍HTTPextender的实现")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("type SchedulerExtender interface {\n    // 最重要的一个接口，输入pod和节点列表，输出是符合调度的节点的列表\n\tFilter(pod *v1.Pod,\n\t\tnodes []*v1.Node, nodeNameToInfo map[string]*schedulercache.NodeInfo,\n\t) (filteredNodes []*v1.Node, failedNodesMap schedulerapi.FailedNodesMap, err error)\n\n    // 这个给节点打分的，优选时需要用的\n\tPrioritize(pod *v1.Pod, nodes []*v1.Node) (hostPriorities *schedulerapi.HostPriorityList, weight int, err error)\n\n    // Bind接口主要是最终调度器选中节点哪个节点时通知extender\n\tBind(binding *v1.Binding) error\n\n\t// IsBinder returns whether this extender is configured for the Bind method.\n\tIsBinder() bool\n\n    // 可以过滤你感兴趣的pod 比如按照标签\n\tIsInterested(pod *v1.Pod) bool\n\n\t// ProcessPreemption returns nodes with their victim pods processed by extender based on\n\t// given:\n\t//   1. Pod to schedule\n\t//   2. Candidate nodes and victim pods (nodeToVictims) generated by previous scheduling process.\n\t//   3. nodeNameToInfo to restore v1.Node from node name if extender cache is enabled.\n\t// The possible changes made by extender may include:\n\t//   1. Subset of given candidate nodes after preemption phase of extender.\n\t//   2. A different set of victim pod for every given candidate node after preemption phase of extender.\n    // 我猜是与亲和性相关的功能，不太清楚 TODO\n\tProcessPreemption(\n\t\tpod *v1.Pod,\n\t\tnodeToVictims map[*v1.Node]*schedulerapi.Victims,\n\t\tnodeNameToInfo map[string]*schedulercache.NodeInfo,\n\t) (map[*v1.Node]*schedulerapi.Victims, error)\n\n    // 优先级抢占特性，可不实现\n\tSupportsPreemption() bool\n\n    // 当访问不到extender时怎么处理，返回真时extender获取不到时调度不能失败\n\tIsIgnorable() bool\n}\n")])])]),a("p",[e._v("官方实现了HTTPextender，可以看下：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("type HTTPExtender struct {\n\textenderURL      string\n\tpreemptVerb      string\n\tfilterVerb       string  # 预选RUL\n\tprioritizeVerb   string  # 优选RUL\n\tbindVerb         string\n\tweight           int\n\tclient           *http.Client\n\tnodeCacheCapable bool\n\tmanagedResources sets.String\n\tignorable        bool\n}\n")])])]),a("p",[e._v("看其预选和优选逻辑：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("args = &schedulerapi.ExtenderArgs{  # 调度的是哪个pod，哪些节点符合调度条件, 返回的也是这个结构体\n\tPod:       pod,\n\tNodes:     nodeList,\n\tNodeNames: nodeNames,\n}\n\nif err := h.send(h.filterVerb, args, &result); err != nil { # 发了个http请求给extender(你要去实现的httpserver), 返回过滤后的结构\n\treturn nil, nil, err\n}\n")])])]),a("h2",{attrs:{id:"httpextender配置参数从哪来"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#httpextender配置参数从哪来"}},[e._v("#")]),e._v(" HTTPExtender配置参数从哪来")]),e._v(" "),a("h2",{attrs:{id:"scheduler-extender配置："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#scheduler-extender配置："}},[e._v("#")]),e._v(" scheduler extender配置：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('NamespaceSystem string = "kube-system"\n\nSchedulerDefaultLockObjectNamespace string = metav1.NamespaceSystem\n\n// SchedulerPolicyConfigMapKey defines the key of the element in the\n// scheduler\'s policy ConfigMap that contains scheduler\'s policy config.\nSchedulerPolicyConfigMapKey = "policy.cfg"\n')])])]),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),a("p",[e._v("调度器的代码写的还是挺不错的，相比较于kube-proxy好多了，可扩展性也还可以，不过目测调度器会面临一次大的重构，现阶段调度器对深度学习的批处理任务支持就不好\n而one by one调度的这种设定关系到整个项目的架构，要想优雅的支持更优秀的调度估计重构是跑不掉了")])])}),[],!1,null,null,null);t.default=n.exports}}]);