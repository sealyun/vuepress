(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{211:function(a,n,e){"use strict";e.r(n);var s=e(0),t=Object(s.a)({},(function(){var a=this,n=a.$createElement,e=a._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"容器信号使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#容器信号使用"}},[a._v("#")]),a._v(" 容器信号使用")]),a._v(" "),e("p",[a._v("我们跑在容器中的程序通常想在容器退出之前做一些清理操作，比较常用的方式是监听一个信号，延迟关闭容器。")]),a._v(" "),e("p",[a._v("docker提供了这样的功能：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("╰─➤  docker stop --help\n\nUsage:  docker stop [OPTIONS] CONTAINER [CONTAINER...]\n\nStop one or more running containers\n\nOptions:\n      --help       Print usage\n  -t, --time int   Seconds to wait for stop before killing it (default 10)\n")])])]),a._v(" "),e("p",[a._v("docker 1.13以上版本在创建容器时可直接指定STOP_TIMEOUT 和STOP_SIGNAL参数:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('$ docker run --help\n...\n--stop-signal string                    Signal to stop a container, SIGTERM by default (default "SIGTERM")\n--stop-timeout int                      Timeout (in seconds) to stop a container\n...\n')])])]),e("p",[a._v("但是。。。")]),a._v(" "),e("p",[a._v("我们测试一个：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('package main\n\nimport (\n    "fmt"\n    "os"\n    "os/signal"\n    "syscall"\n    "time"\n)\n\nfunc main() {\n    fmt.Println("signal test")\n    go func() {\n        for {\n            c := make(chan os.Signal, 1)\n            signal.Notify(c, syscall.SIGTERM)\n            s := <-c\n            fmt.Println("Got signal:", s)\n        }\n    }()\n    time.Sleep(time.Second * 100)\n}\n')])])]),e("p",[a._v("Dockerfile:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("FROM dev.reg.iflytek.com/base/golang:1.8.0\nCOPY main.go .\nRUN go build -o signal && cp signal $GOPATH/bin\nCMD signal  \n")])])]),e("p",[a._v("构建：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("docker build -t dev.reg.iflytek.com/test/signal:latest .\n")])])]),e("p",[a._v("运行：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("docker run --name signal dev.reg.iflytek.com/test/signal:latest\n")])])]),e("p",[a._v("再开一终端，运行：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("docker stop -t 10 signal\n")])])]),e("p",[a._v("发现并没有打印出Got signal:... 监听信号失败。")]),a._v(" "),e("p",[a._v("问题再于：我们docker inspect signal看一下\n可以看到")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("Path:/bin/sh\nArgs:[\n  -c,\n  signal\n]\n")])])]),e("p",[a._v("或者docker exec signal ps 看一下可以看到pid为1的进程并不是signal, 而是shell.")]),a._v(" "),e("p",[a._v("所以原因找到了，是因为docker engine只给pid为1的进程发送信号，sh收到了信号而我们想要的signal进程没有收到信号")]),a._v(" "),e("p",[a._v("解决办法：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('FROM dev.reg.iflytek.com/base/golang:1.8.0\nCOPY main.go .\nRUN go build -o signal && cp signal $GOPATH/bin\nCMD ["signal"]  # 不能写成 CMD signal, 这会直接exec，否则会以shell的方式派生子进程。\n')])])])])}),[],!1,null,null,null);n.default=t.exports}}]);