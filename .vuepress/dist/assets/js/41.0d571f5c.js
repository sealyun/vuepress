(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{241:function(e,t,n){"use strict";n.r(t);var r=n(0),a=Object(r.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"kubeadm源码分析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#kubeadm源码分析"}},[e._v("#")]),e._v(" kubeadm源码分析")]),e._v(" "),n("p",[e._v("说句实在话，kubeadm的代码写的真心一般，质量不是很高。")]),e._v(" "),n("p",[e._v("几个关键点来先说一下kubeadm干的几个核心的事：")]),e._v(" "),n("ul",[n("li",[e._v("kubeadm 生成证书在/etc/kubernetes/pki目录下")]),e._v(" "),n("li",[e._v("kubeadm 生成static pod yaml配置，全部在/etc/kubernetes/manifasts下")]),e._v(" "),n("li",[e._v("kubeadm 生成kubelet配置，kubectl配置等 在/etc/kubernetes下")]),e._v(" "),n("li",[e._v("kubeadm 通过client go去启动dns\n")])]),e._v(" "),n("h2",{attrs:{id:"kubeadm-init"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#kubeadm-init"}},[e._v("#")]),e._v(" kubeadm init")]),e._v(" "),n("p",[e._v("代码入口 "),n("code",[e._v("cmd/kubeadm/app/cmd/init.go")]),e._v(" 建议大家去看看cobra")]),e._v(" "),n("p",[e._v("找到Run函数来分析下主要流程：")]),e._v(" "),n("ol",[n("li",[e._v("如果证书不存在，就创建证书，所以如果我们有自己的证书可以把它放在/etc/kubernetes/pki下即可, 下文细看如果生成证书")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("\tif res, _ := certsphase.UsingExternalCA(i.cfg); !res {\n\t\tif err := certsphase.CreatePKIAssets(i.cfg); err != nil {\n\t\t\treturn err\n\t\t}\n")])])]),n("ol",{attrs:{start:"2"}},[n("li",[e._v("创建kubeconfig文件")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("\t\tif err := kubeconfigphase.CreateInitKubeConfigFiles(kubeConfigDir, i.cfg); err != nil {\n\t\t\treturn err\n\t\t}\n")])])]),n("ol",{attrs:{start:"3"}},[n("li",[e._v("创建manifest文件，etcd apiserver manager scheduler都在这里创建, 可以看到如果你的配置文件里已经写了etcd的地址了，就不创建了，这我们就可以自己装etcd集群，而不用默认单点的etcd，很有用")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('controlplanephase.CreateInitStaticPodManifestFiles(manifestDir, i.cfg); \nif len(i.cfg.Etcd.Endpoints) == 0 {\n\tif err := etcdphase.CreateLocalEtcdStaticPodManifestFile(manifestDir, i.cfg); err != nil {\n\t\treturn fmt.Errorf("error creating local etcd static pod manifest file: %v", err)\n\t}\n}\n')])])]),n("ol",{attrs:{start:"4"}},[n("li",[e._v("等待APIserver和kubelet启动成功，这里就会遇到我们经常遇到的镜像拉不下来的错误，其实有时kubelet因为别的原因也会报这个错，让人误以为是镜像弄不下来")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('if err := waitForAPIAndKubelet(waiter); err != nil {\n\tctx := map[string]string{\n\t\t"Error":                  fmt.Sprintf("%v", err),\n\t\t"APIServerImage":         images.GetCoreImage(kubeadmconstants.KubeAPIServer, i.cfg.GetControlPlaneImageRepository(), i.cfg.KubernetesVersion, i.cfg.UnifiedControlPlaneImage),\n\t\t"ControllerManagerImage": images.GetCoreImage(kubeadmconstants.KubeControllerManager, i.cfg.GetControlPlaneImageRepository(), i.cfg.KubernetesVersion, i.cfg.UnifiedControlPlaneImage),\n\t\t"SchedulerImage":         images.GetCoreImage(kubeadmconstants.KubeScheduler, i.cfg.GetControlPlaneImageRepository(), i.cfg.KubernetesVersion, i.cfg.UnifiedControlPlaneImage),\n\t}\n\n\tkubeletFailTempl.Execute(out, ctx)\n\n\treturn fmt.Errorf("couldn\'t initialize a Kubernetes cluster")\n}\n')])])]),n("ol",{attrs:{start:"5"}},[n("li",[e._v("给master加标签，加污点, 所以想要pod调度到master上可以把污点清除了")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('if err := markmasterphase.MarkMaster(client, i.cfg.NodeName); err != nil {\n\treturn fmt.Errorf("error marking master: %v", err)\n}\n')])])]),n("ol",{attrs:{start:"6"}},[n("li",[e._v("生成tocken")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('if err := nodebootstraptokenphase.UpdateOrCreateToken(client, i.cfg.Token, false, i.cfg.TokenTTL.Duration, kubeadmconstants.DefaultTokenUsages, []string{kubeadmconstants.NodeBootstrapTokenAuthGroup}, tokenDescription); err != nil {\n\treturn fmt.Errorf("error updating or creating token: %v", err)\n}\n')])])]),n("ol",{attrs:{start:"7"}},[n("li",[e._v("调用clientgo创建dns和kube-proxy")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('if err := dnsaddonphase.EnsureDNSAddon(i.cfg, client); err != nil {\n\treturn fmt.Errorf("error ensuring dns addon: %v", err)\n}\n\nif err := proxyaddonphase.EnsureProxyAddon(i.cfg, client); err != nil {\n\treturn fmt.Errorf("error ensuring proxy addon: %v", err)\n}\n')])])]),n("p",[e._v("笔者批判代码无脑式的一个流程到底，要是笔者操刀定抽象成接口 RenderConf Save Run Clean等，DNS kube-porxy以及其它组件去实现，然后问题就是没把dns和kubeproxy的配置渲染出来，可能是它们不是static pod的原因, 然后就是join时的bug下文提到")]),e._v(" "),n("h3",{attrs:{id:"证书生成"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#证书生成"}},[e._v("#")]),e._v(" 证书生成")]),e._v(" "),n("p",[e._v("循环的调用了这一坨函数，我们只需要看其中一两个即可，其它的都差不多")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("certActions := []func(cfg *kubeadmapi.MasterConfiguration) error{\n\tCreateCACertAndKeyfiles,\n\tCreateAPIServerCertAndKeyFiles,\n\tCreateAPIServerKubeletClientCertAndKeyFiles,\n\tCreateServiceAccountKeyAndPublicKeyFiles,\n\tCreateFrontProxyCACertAndKeyFiles,\n\tCreateFrontProxyClientCertAndKeyFiles,\n}\n")])])]),n("p",[e._v("根证书生成：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('\n//返回了根证书的公钥和私钥\nfunc NewCACertAndKey() (*x509.Certificate, *rsa.PrivateKey, error) {\n\n\tcaCert, caKey, err := pkiutil.NewCertificateAuthority()\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf("failure while generating CA certificate and key: %v", err)\n\t}\n\n\treturn caCert, caKey, nil\n}\n\n')])])]),n("p",[e._v("k8s.io/client-go/util/cert 这个库里面有两个函数，一个生成key的一个生成cert的：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('key, err := certutil.NewPrivateKey()\nconfig := certutil.Config{\n\tCommonName: "kubernetes",\n}\ncert, err := certutil.NewSelfSignedCACert(config, key)\n')])])]),n("p",[e._v("config里面我们也可以填充一些别的证书信息：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("type Config struct {\n\tCommonName   string\n\tOrganization []string\n\tAltNames     AltNames\n\tUsages       []x509.ExtKeyUsage\n}\n")])])]),n("p",[e._v("私钥就是封装了rsa库里面的函数：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('\t"crypto/rsa"\n\t"crypto/x509"\nfunc NewPrivateKey() (*rsa.PrivateKey, error) {\n\treturn rsa.GenerateKey(cryptorand.Reader, rsaKeySize)\n}\n')])])]),n("p",[e._v("自签证书,所以根证书里只有CommonName信息，Organization相当于没设置：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("func NewSelfSignedCACert(cfg Config, key *rsa.PrivateKey) (*x509.Certificate, error) {\n\tnow := time.Now()\n\ttmpl := x509.Certificate{\n\t\tSerialNumber: new(big.Int).SetInt64(0),\n\t\tSubject: pkix.Name{\n\t\t\tCommonName:   cfg.CommonName,\n\t\t\tOrganization: cfg.Organization,\n\t\t},\n\t\tNotBefore:             now.UTC(),\n\t\tNotAfter:              now.Add(duration365d * 10).UTC(),\n\t\tKeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature | x509.KeyUsageCertSign,\n\t\tBasicConstraintsValid: true,\n\t\tIsCA: true,\n\t}\n\n\tcertDERBytes, err := x509.CreateCertificate(cryptorand.Reader, &tmpl, &tmpl, key.Public(), key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn x509.ParseCertificate(certDERBytes)\n}\n")])])]),n("p",[e._v("生成好之后把之写入文件：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(" pkiutil.WriteCertAndKey(pkiDir, baseName, cert, key);\ncertutil.WriteCert(certificatePath, certutil.EncodeCertPEM(cert))\n")])])]),n("p",[e._v("这里调用了pem库进行了编码")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("encoding/pem\n\nfunc EncodeCertPEM(cert *x509.Certificate) []byte {\n\tblock := pem.Block{\n\t\tType:  CertificateBlockType,\n\t\tBytes: cert.Raw,\n\t}\n\treturn pem.EncodeToMemory(&block)\n}\n")])])]),n("p",[e._v("然后我们看apiserver的证书生成：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("caCert, caKey, err := loadCertificateAuthorithy(cfg.CertificatesDir, kubeadmconstants.CACertAndKeyBaseName)\n//从根证书生成apiserver证书\napiCert, apiKey, err := NewAPIServerCertAndKey(cfg, caCert, caKey)\n")])])]),n("p",[e._v("这时需要关注AltNames了比较重要，所有需要访问master的地址域名都得加进去，对应配置文件中apiServerCertSANs字段,其它东西与根证书无差别")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("config := certutil.Config{\n\tCommonName: kubeadmconstants.APIServerCertCommonName,\n\tAltNames:   *altNames,\n\tUsages:     []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},\n}\n")])])]),n("h3",{attrs:{id:"创建k8s配置文件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#创建k8s配置文件"}},[e._v("#")]),e._v(" 创建k8s配置文件")]),e._v(" "),n("p",[e._v("可以看到创建了这些文件")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("return createKubeConfigFiles(\n\toutDir,\n\tcfg,\n\tkubeadmconstants.AdminKubeConfigFileName,\n\tkubeadmconstants.KubeletKubeConfigFileName,\n\tkubeadmconstants.ControllerManagerKubeConfigFileName,\n\tkubeadmconstants.SchedulerKubeConfigFileName,\n)\n")])])]),n("p",[e._v("k8s封装了两个渲染配置的函数：\n区别是你的kubeconfig文件里会不会产生token，比如你进入dashboard需要一个token，或者你调用api需要一个token那么请生成带token的配置\n生成的conf文件基本一直只是比如ClientName这些东西不同，所以加密后的证书也不同，ClientName会被加密到证书里，然后k8s取出来当用户使用")]),e._v(" "),n("p",[e._v("所以重点来了，我们做多租户时也要这样去生成。然后给该租户绑定角色。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('return kubeconfigutil.CreateWithToken(\n\tspec.APIServer,\n\t"kubernetes",\n\tspec.ClientName,\n\tcertutil.EncodeCertPEM(spec.CACert),\n\tspec.TokenAuth.Token,\n), nil\n\nreturn kubeconfigutil.CreateWithCerts(\n\tspec.APIServer,\n\t"kubernetes",\n\tspec.ClientName,\n\tcertutil.EncodeCertPEM(spec.CACert),\n\tcertutil.EncodePrivateKeyPEM(clientKey),\n\tcertutil.EncodeCertPEM(clientCert),\n), nil\n')])])]),n("p",[e._v("然后就是填充Config结构体喽, 最后写到文件里，略")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('"k8s.io/client-go/tools/clientcmd/api\nreturn &clientcmdapi.Config{\n\tClusters: map[string]*clientcmdapi.Cluster{\n\t\tclusterName: {\n\t\t\tServer: serverURL,\n\t\t\tCertificateAuthorityData: caCert,\n\t\t},\n\t},\n\tContexts: map[string]*clientcmdapi.Context{\n\t\tcontextName: {\n\t\t\tCluster:  clusterName,\n\t\t\tAuthInfo: userName,\n\t\t},\n\t},\n\tAuthInfos:      map[string]*clientcmdapi.AuthInfo{},\n\tCurrentContext: contextName,\n}\n')])])]),n("h3",{attrs:{id:"创建static-pod-yaml文件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#创建static-pod-yaml文件"}},[e._v("#")]),e._v(" 创建static pod yaml文件")]),e._v(" "),n("p",[e._v("这里返回了apiserver manager scheduler的pod结构体,")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('specs := GetStaticPodSpecs(cfg, k8sVersion)\nstaticPodSpecs := map[string]v1.Pod{\n\tkubeadmconstants.KubeAPIServer: staticpodutil.ComponentPod(v1.Container{\n\t\tName:          kubeadmconstants.KubeAPIServer,\n\t\tImage:         images.GetCoreImage(kubeadmconstants.KubeAPIServer, cfg.GetControlPlaneImageRepository(), cfg.KubernetesVersion, cfg.UnifiedControlPlaneImage),\n\t\tCommand:       getAPIServerCommand(cfg, k8sVersion),\n\t\tVolumeMounts:  staticpodutil.VolumeMountMapToSlice(mounts.GetVolumeMounts(kubeadmconstants.KubeAPIServer)),\n\t\tLivenessProbe: staticpodutil.ComponentProbe(cfg, kubeadmconstants.KubeAPIServer, int(cfg.API.BindPort), "/healthz", v1.URISchemeHTTPS),\n\t\tResources:     staticpodutil.ComponentResources("250m"),\n\t\tEnv:           getProxyEnvVars(),\n\t}, mounts.GetVolumes(kubeadmconstants.KubeAPIServer)),\n\tkubeadmconstants.KubeControllerManager: staticpodutil.ComponentPod(v1.Container{\n\t\tName:          kubeadmconstants.KubeControllerManager,\n\t\tImage:         images.GetCoreImage(kubeadmconstants.KubeControllerManager, cfg.GetControlPlaneImageRepository(), cfg.KubernetesVersion, cfg.UnifiedControlPlaneImage),\n\t\tCommand:       getControllerManagerCommand(cfg, k8sVersion),\n\t\tVolumeMounts:  staticpodutil.VolumeMountMapToSlice(mounts.GetVolumeMounts(kubeadmconstants.KubeControllerManager)),\n\t\tLivenessProbe: staticpodutil.ComponentProbe(cfg, kubeadmconstants.KubeControllerManager, 10252, "/healthz", v1.URISchemeHTTP),\n\t\tResources:     staticpodutil.ComponentResources("200m"),\n\t\tEnv:           getProxyEnvVars(),\n\t}, mounts.GetVolumes(kubeadmconstants.KubeControllerManager)),\n\tkubeadmconstants.KubeScheduler: staticpodutil.ComponentPod(v1.Container{\n\t\tName:          kubeadmconstants.KubeScheduler,\n\t\tImage:         images.GetCoreImage(kubeadmconstants.KubeScheduler, cfg.GetControlPlaneImageRepository(), cfg.KubernetesVersion, cfg.UnifiedControlPlaneImage),\n\t\tCommand:       getSchedulerCommand(cfg),\n\t\tVolumeMounts:  staticpodutil.VolumeMountMapToSlice(mounts.GetVolumeMounts(kubeadmconstants.KubeScheduler)),\n\t\tLivenessProbe: staticpodutil.ComponentProbe(cfg, kubeadmconstants.KubeScheduler, 10251, "/healthz", v1.URISchemeHTTP),\n\t\tResources:     staticpodutil.ComponentResources("100m"),\n\t\tEnv:           getProxyEnvVars(),\n\t}, mounts.GetVolumes(kubeadmconstants.KubeScheduler)),\n}\n\n//获取特定版本的镜像\nfunc GetCoreImage(image, repoPrefix, k8sVersion, overrideImage string) string {\n\tif overrideImage != "" {\n\t\treturn overrideImage\n\t}\n\tkubernetesImageTag := kubeadmutil.KubernetesVersionToImageTag(k8sVersion)\n\tetcdImageTag := constants.DefaultEtcdVersion\n\tetcdImageVersion, err := constants.EtcdSupportedVersion(k8sVersion)\n\tif err == nil {\n\t\tetcdImageTag = etcdImageVersion.String()\n\t}\n\treturn map[string]string{\n\t\tconstants.Etcd:                  fmt.Sprintf("%s/%s-%s:%s", repoPrefix, "etcd", runtime.GOARCH, etcdImageTag),\n\t\tconstants.KubeAPIServer:         fmt.Sprintf("%s/%s-%s:%s", repoPrefix, "kube-apiserver", runtime.GOARCH, kubernetesImageTag),\n\t\tconstants.KubeControllerManager: fmt.Sprintf("%s/%s-%s:%s", repoPrefix, "kube-controller-manager", runtime.GOARCH, kubernetesImageTag),\n\t\tconstants.KubeScheduler:         fmt.Sprintf("%s/%s-%s:%s", repoPrefix, "kube-scheduler", runtime.GOARCH, kubernetesImageTag),\n\t}[image]\n}\n//然后就把这个pod写到文件里了，比较简单\n staticpodutil.WriteStaticPodToDisk(componentName, manifestDir, spec); \n')])])]),n("p",[e._v("创建etcd的一样，不多废话")]),e._v(" "),n("h3",{attrs:{id:"等待kubelet启动成功"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#等待kubelet启动成功"}},[e._v("#")]),e._v(" 等待kubelet启动成功")]),e._v(" "),n("p",[e._v("这个错误非常容易遇到，看到这个基本就是kubelet没起来，我们需要检查：selinux swap 和Cgroup driver是不是一致\nsetenforce 0 && swapoff -a && systemctl restart kubelet如果不行请保证 kubelet的Cgroup driver与docker一致，docker info|grep Cg")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('go func(errC chan error, waiter apiclient.Waiter) {\n\t// This goroutine can only make kubeadm init fail. If this check succeeds, it won\'t do anything special\n\tif err := waiter.WaitForHealthyKubelet(40*time.Second, "http://localhost:10255/healthz"); err != nil {\n\t\terrC <- err\n\t}\n}(errorChan, waiter)\n\ngo func(errC chan error, waiter apiclient.Waiter) {\n\t// This goroutine can only make kubeadm init fail. If this check succeeds, it won\'t do anything special\n\tif err := waiter.WaitForHealthyKubelet(60*time.Second, "http://localhost:10255/healthz/syncloop"); err != nil {\n\t\terrC <- err\n\t}\n}(errorChan, waiter)\n')])])]),n("h3",{attrs:{id:"创建dns和kubeproxy"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#创建dns和kubeproxy"}},[e._v("#")]),e._v(" 创建DNS和kubeproxy")]),e._v(" "),n("p",[e._v("我就是在此发现coreDNS的")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("if features.Enabled(cfg.FeatureGates, features.CoreDNS) {\n\treturn coreDNSAddon(cfg, client, k8sVersion)\n}\nreturn kubeDNSAddon(cfg, client, k8sVersion)\n")])])]),n("p",[e._v("然后coreDNS的yaml配置模板直接是写在代码里的：\n/app/phases/addons/dns/manifests.go")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("\tCoreDNSDeployment = `\napiVersion: apps/v1beta2\nkind: Deployment\nmetadata:\n  name: coredns\n  namespace: kube-system\n  labels:\n    k8s-app: kube-dns\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      k8s-app: kube-dns\n  template:\n    metadata:\n      labels:\n        k8s-app: kube-dns\n    spec:\n      serviceAccountName: coredns\n      tolerations:\n      - key: CriticalAddonsOnly\n        operator: Exists\n      - key: {{ .MasterTaintKey }}\n...\n")])])]),n("p",[e._v("然后渲染模板，最后调用k8sapi创建,这种创建方式可以学习一下，虽然有点拙劣，这地方写的远不如kubectl好")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('coreDNSConfigMap := &v1.ConfigMap{}\nif err := kuberuntime.DecodeInto(legacyscheme.Codecs.UniversalDecoder(), configBytes, coreDNSConfigMap); err != nil {\n\treturn fmt.Errorf("unable to decode CoreDNS configmap %v", err)\n}\n\n// Create the ConfigMap for CoreDNS or update it in case it already exists\nif err := apiclient.CreateOrUpdateConfigMap(client, coreDNSConfigMap); err != nil {\n\treturn err\n}\n\ncoreDNSClusterRoles := &rbac.ClusterRole{}\nif err := kuberuntime.DecodeInto(legacyscheme.Codecs.UniversalDecoder(), []byte(CoreDNSClusterRole), coreDNSClusterRoles); err != nil {\n\treturn fmt.Errorf("unable to decode CoreDNS clusterroles %v", err)\n}\n...\n')])])]),n("p",[e._v("这里值得一提的是kubeproxy的configmap真应该把apiserver地址传入进来，允许自定义，因为做高可用时需要指定虚拟ip，得修改，很麻烦\nkubeproxy大差不差，不说了,想改的话改： app/phases/addons/proxy/manifests.go")]),e._v(" "),n("h2",{attrs:{id:"kubeadm-join"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#kubeadm-join"}},[e._v("#")]),e._v(" kubeadm join")]),e._v(" "),n("p",[e._v("kubeadm join比较简单，一句话就可以说清楚，获取cluster info, 创建kubeconfig，怎么创建的kubeinit里面已经说了。带上token让kubeadm有权限\n可以拉取")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('return https.RetrieveValidatedClusterInfo(cfg.DiscoveryFile)\n\ncluster info内容\ntype Cluster struct {\n\t// LocationOfOrigin indicates where this object came from.  It is used for round tripping config post-merge, but never serialized.\n\tLocationOfOrigin string\n\t// Server is the address of the kubernetes cluster (https://hostname:port).\n\tServer string `json:"server"`\n\t// InsecureSkipTLSVerify skips the validity check for the server\'s certificate. This will make your HTTPS connections insecure.\n\t// +optional\n\tInsecureSkipTLSVerify bool `json:"insecure-skip-tls-verify,omitempty"`\n\t// CertificateAuthority is the path to a cert file for the certificate authority.\n\t// +optional\n\tCertificateAuthority string `json:"certificate-authority,omitempty"`\n\t// CertificateAuthorityData contains PEM-encoded certificate authority certificates. Overrides CertificateAuthority\n\t// +optional\n\tCertificateAuthorityData []byte `json:"certificate-authority-data,omitempty"`\n\t// Extensions holds additional information. This is useful for extenders so that reads and writes don\'t clobber unknown fields\n\t// +optional\n\tExtensions map[string]runtime.Object `json:"extensions,omitempty"`\n}\n\nreturn kubeconfigutil.CreateWithToken(\n\tclusterinfo.Server,\n\t"kubernetes",\n\tTokenUser,\n\tclusterinfo.CertificateAuthorityData,\n\tcfg.TLSBootstrapToken,\n), nil\n')])])]),n("p",[e._v("CreateWithToken上文提到了不再赘述，这样就能去生成kubelet配置文件了，然后把kubelet启动起来即可")]),e._v(" "),n("p",[e._v("kubeadm join的问题就是渲染配置时没有使用命令行传入的apiserver地址，而用clusterinfo里的地址，这不利于我们做高可用，可能我们传入一个虚拟ip，但是配置里还是apiser的地址")])])}),[],!1,null,null,null);t.default=a.exports}}]);