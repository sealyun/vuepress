(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{211:function(n,e,t){"use strict";t.r(e);var a=t(0),r=Object(a.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"cni详细介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cni详细介绍"}},[n._v("#")]),n._v(" CNI详细介绍")]),n._v(" "),t("p",[n._v("CNI接口很简单，特别一些新手一定要克服恐惧心里，和我一探究竟，本文结合原理与实践，认真读下来一定会对原理理解非常透彻。\n")]),n._v(" "),t("p",[t("img",{attrs:{src:"https://sealyun.com/CNI.png",alt:""}})]),n._v(" "),t("h2",{attrs:{id:"环境介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#环境介绍"}},[n._v("#")]),n._v(" 环境介绍")]),n._v(" "),t("p",[n._v("我们安装kubernetes时先不安装CNI. 如果使用了"),t("a",{attrs:{href:"https://store.lameleg.com",target:"_blank",rel:"noopener noreferrer"}},[n._v("sealyun离线包"),t("OutboundLink")],1),n._v(" 那么修改下 "),t("code",[n._v("kube/conf/master.sh")])]),n._v(" "),t("p",[n._v("只留如下内容即可：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("[root@helix105 shell]# cat master.sh \nkubeadm init --config ../conf/kubeadm.yaml\nmkdir ~/.kube\ncp /etc/kubernetes/admin.conf ~/.kube/config\n\nkubectl taint nodes --all node-role.kubernetes.io/master-\n")])])]),t("p",[n._v("清空CNI相关目录：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("rm -rf /opt/cni/bin/*\nrm -rf /etc/cni/net.d/*\n")])])]),t("p",[n._v("启动kubernetes, 如果已经装过那么kubeadm reset一下:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("cd kube/shell && sh init.sh && sh master.sh\n")])])]),t("p",[n._v("此时你的节点是notready的，你的coredns也没有办法分配到地址：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("[root@helix105 shell]# kubectl get pod -n kube-system -o wide\nNAME                                            READY   STATUS    RESTARTS   AGE   IP              NODE                    NOMINATED NODE   READINESS GATES\ncoredns-5c98db65d4-5fh6c                        0/1     Pending   0          54s   <none>          <none>                  <none>           <none>\ncoredns-5c98db65d4-dbwmq                        0/1     Pending   0          54s   <none>          <none>                  <none>           <none>\nkube-controller-manager-helix105.hfa.chenqian   1/1     Running   0          19s   172.16.60.105   helix105.hfa.chenqian   <none>           <none>\nkube-proxy-k74ld                                1/1     Running   0          54s   172.16.60.105   helix105.hfa.chenqian   <none>           <none>\nkube-scheduler-helix105.hfa.chenqian            1/1     Running   0          14s   172.16.60.105   helix105.hfa.chenqian   <none>           <none>\n[root@helix105 shell]# kubectl get node\nNAME                    STATUS     ROLES    AGE   VERSION\nhelix105.hfa.chenqian   NotReady   master   86s   v1.15.0\n")])])]),t("h2",{attrs:{id:"安装cni"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#安装cni"}},[n._v("#")]),n._v(" 安装CNI")]),n._v(" "),t("blockquote",[t("p",[n._v("创建CNI配置文件")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('$ mkdir -p /etc/cni/net.d\n$ cat >/etc/cni/net.d/10-mynet.conf <<EOF\n{\n\t"cniVersion": "0.2.0",\n\t"name": "mynet",\n\t"type": "bridge",\n\t"bridge": "cni0",\n\t"isGateway": true,\n\t"ipMasq": true,\n\t"ipam": {\n\t\t"type": "host-local",\n\t\t"subnet": "10.22.0.0/16",\n\t\t"routes": [\n\t\t\t{ "dst": "0.0.0.0/0" }\n\t\t]\n\t}\n}\nEOF\n$ cat >/etc/cni/net.d/99-loopback.conf <<EOF\n{\n\t"cniVersion": "0.2.0",\n\t"name": "lo",\n\t"type": "loopback"\n}\nEOF\n')])])]),t("p",[n._v("这里两个配置一个是给容器塞一个网卡挂在网桥上的，另外一个配置负责撸(本地回环)。。")]),n._v(" "),t("p",[n._v("配置完后会发现节点ready:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("[root@helix105 shell]# kubectl get node\nNAME                    STATUS   ROLES    AGE   VERSION\nhelix105.hfa.chenqian   Ready    master   15m   v1.15.0\n")])])]),t("p",[n._v("但是coredns会一直处于ContainerCreating状态,是因为bin文件还没有:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('failed to find plugin "bridge" in path [/opt/cni/bin]\n')])])]),t("p",[t("a",{attrs:{href:"https://github.com/containernetworking/plugins",target:"_blank",rel:"noopener noreferrer"}},[n._v("plugins"),t("OutboundLink")],1),n._v("里实现了很多的CNI,如我们上面配置的bridge.")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("$ cd $GOPATH/src/github.com/containernetworking/plugins\n$ ./build_linux.sh\n$ cp bin/* /opt/cni/bin\n$ ls bin/\nbandwidth  dhcp      flannel      host-local  loopback  portmap  sbr     tuning\nbridge     firewall  host-device  ipvlan      macvlan   ptp      static  vlan\n")])])]),t("p",[n._v("这里有很多二进制，我们学习的话不需要关注所有的，就看ptp(就简单的创建了设备对)或者bridge")]),n._v(" "),t("p",[n._v("再看coredns已经能分配到地址了：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("[root@helix105 plugins]# kubectl get pod -n kube-system -o wide\nNAME                                            READY   STATUS    RESTARTS   AGE     IP              NODE                    NOMINATED NODE   READINESS GATES\ncoredns-5c98db65d4-5fh6c                        1/1     Running   0          3h10m   10.22.0.8       helix105.hfa.chenqian   <none>           <none>\ncoredns-5c98db65d4-dbwmq                        1/1     Running   0          3h10m   10.22.0.9\n")])])]),t("p",[n._v("看一下网桥,cni0上挂了两个设备,与我们上面的cni配置里配置的一样，type字段指定用哪个bin文件，bridge字段指定网桥名：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("[root@helix105 plugins]# brctl show\nbridge name\tbridge id\t\tSTP enabled\tinterfaces\ncni0\t\t8000.8ef6ac49c2f7\tno\t\tveth1b28b06f\n            \t\t\t\t\t\t\tveth1c093940\n")])])]),t("h2",{attrs:{id:"原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[n._v("#")]),n._v(" 原理")]),n._v(" "),t("p",[n._v("为了更好理解kubelet干嘛了，我们可以找一个脚本来解释 "),t("a",{attrs:{href:"https://github.com/containernetworking/cni/tree/master/scripts",target:"_blank",rel:"noopener noreferrer"}},[n._v("script"),t("OutboundLink")],1),n._v(" 这个脚本也可以用来测试你的CNI：")]),n._v(" "),t("p",[n._v("为了易读，我删除一些不重要的东西,原版脚本可以在连接中去拿")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("# 先创建一个容器，这里只为了拿到一个net namespace\ncontid=$(docker run -d --net=none golang:1.12.7 /bin/sleep 10000000) \npid=$(docker inspect -f '{{ .State.Pid }}' $contid)\nnetnspath=/proc/$pid/ns/net # 这个我们需要\n\nkubelet启动pod时也是创建好容器就有了pod的network namespaces，再去把ns传给cni 让cni去配置\n\n./exec-plugins.sh add $contid $netnspath # 传入两个参数给下一个脚本，containerid和net namespace路径\n\ndocker run --net=container:$contid $@\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("NETCONFPATH=${NETCONFPATH-/etc/cni/net.d}\n\ni=0\n# 获取容器id和网络ns\ncontid=$2 \nnetns=$3\n\n# 这里设置了几个环境变量，CNI命令行工具就可以获取到这些参数\nexport CNI_COMMAND=$(echo $1 | tr '[:lower:]' '[:upper:]')\nexport PATH=$CNI_PATH:$PATH # 这个指定CNI bin文件的路径\nexport CNI_CONTAINERID=$contid \nexport CNI_NETNS=$netns\n\nfor netconf in $(echo $NETCONFPATH/10-mynet.conf | sort); do\n        name=$(jq -r '.name' <$netconf)\n        plugin=$(jq -r '.type' <$netconf) # CNI配置文件的type字段对应二进制程序名\n        export CNI_IFNAME=$(printf eth%d $i) # 容器内网卡名\n\n        # 这里执行了命令行工具\n        res=$($plugin <$netconf) # 这里把CNI的配置文件通过标准输入也传给CNI命令行工具\n        if [ $? -ne 0 ]; then\n                # 把结果输出到标准输出，这样kubelet就可以拿到容器地址等一些信息\n                errmsg=$(echo $res | jq -r '.msg')\n                if [ -z \"$errmsg\" ]; then\n                        errmsg=$res\n                fi\n\n                echo \"${name} : error executing $CNI_COMMAND: $errmsg\"\n                exit 1\n        let \"i=i+1\"\ndone\n")])])]),t("p",[n._v("总结一下：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("         CNI配置文件\n         容器ID\n         网络ns\nkubelet --------------\x3e  CNI command\n   ^                        |\n   |                        |\n   +------------------------+\n       结果标准输出\n")])])]),t("h3",{attrs:{id:"bridge-cni实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bridge-cni实现"}},[n._v("#")]),n._v(" bridge CNI实现")]),n._v(" "),t("p",[n._v("既然这么简单，那么就可以去看看实现了：")]),n._v(" "),t("p",[t("a",{attrs:{href:"https://github.com/containernetworking/plugins/tree/master/plugins/main/bridge",target:"_blank",rel:"noopener noreferrer"}},[n._v("bridge CNI代码"),t("OutboundLink")],1)]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//cmdAdd 负责创建网络\nfunc cmdAdd(args *skel.CmdArgs) error \n\n//入参数都已经写到这里面了，前面的参数从环境变量读取的，CNI配置从stdin读取的\ntype CmdArgs struct {\n\tContainerID string\n\tNetns       string\n\tIfName      string\n\tArgs        string //这个里面携带一些额外参数, 如pod name等\n\tPath        string\n\tStdinData   []byte\n}\n")])])]),t("p",[n._v("所以CNI配置文件除了name type这些特定字段，你自己也可以加自己的一些字段.然后自己去解析")]),n._v(" "),t("p",[n._v("然后啥事都得靠自己了")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//这里创建了设备对，并挂载到cni0王桥上\nhostInterface, containerInterface, err := setupVeth(netns, br, args.IfName, n.MTU, n.HairpinMode, n.Vlan)\n")])])]),t("p",[n._v("具体怎么挂的就是调用了"),t("a",{attrs:{href:"github.com/vishvananda/netlink"}},[n._v("netlink")]),n._v(" 这个库，sealos在做内核负载时同样用了该库。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("err := netns.Do(func(hostNS ns.NetNS) error { //创建设备对\n\thostVeth, containerVeth, err := ip.SetupVeth(ifName, mtu, hostNS)\n    ...\n    //配置容器内的网卡名mac地址等\n\tcontIface.Name = containerVeth.Name\n\tcontIface.Mac = containerVeth.HardwareAddr.String()\n\tcontIface.Sandbox = netns.Path()\n\thostIface.Name = hostVeth.Name\n\treturn nil\n})\n...\n\n// 根据index找到宿主机设备对名\nhostVeth, err := netlink.LinkByName(hostIface.Name)\n...\nhostIface.Mac = hostVeth.Attrs().HardwareAddr.String()\n\n// 把宿主机端设备对挂给网桥\nif err := netlink.LinkSetMaster(hostVeth, br); err != nil {}\n\n// 设置hairpin mode\nif err = netlink.LinkSetHairpin(hostVeth, hairpinMode); err != nil {\n}\n\n// 设置vlanid\nif vlanID != 0 {\n\terr = netlink.BridgeVlanAdd(hostVeth, uint16(vlanID), true, true, false, true)\n}\n\nreturn hostIface, contIface, nil\n")])])]),t("p",[n._v("最后把结果返回：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('type Result struct {\n\tCNIVersion string         `json:"cniVersion,omitempty"`\n\tInterfaces []*Interface   `json:"interfaces,omitempty"`\n\tIPs        []*IPConfig    `json:"ips,omitempty"`\n\tRoutes     []*types.Route `json:"routes,omitempty"`\n\tDNS        types.DNS      `json:"dns,omitempty"`\n}\n\n// 这样kubelet就收到返回信息了\nfunc (r *Result) PrintTo(writer io.Writer) error {\n\tdata, err := json.MarshalIndent(r, "", "    ")\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = writer.Write(data)\n\treturn err\n}\n')])])]),t("p",[n._v("如：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('{\n  "cniVersion": "0.4.0",\n  "interfaces": [                                            (this key omitted by IPAM plugins)\n      {\n          "name": "<name>",\n          "mac": "<MAC address>",                            (required if L2 addresses are meaningful)\n          "sandbox": "<netns path or hypervisor identifier>" (required for container/hypervisor interfaces, empty/omitted for host interfaces)\n      }\n  ],\n  "ips": [\n      {\n          "version": "<4-or-6>",\n          "address": "<ip-and-prefix-in-CIDR>",\n          "gateway": "<ip-address-of-the-gateway>",          (optional)\n          "interface": <numeric index into \'interfaces\' list>\n      },\n      ...\n  ],\n  "routes": [                                                (optional)\n      {\n          "dst": "<ip-and-prefix-in-cidr>",\n          "gw": "<ip-of-next-hop>"                           (optional)\n      },\n      ...\n  ],\n  "dns": {                                                   (optional)\n    "nameservers": <list-of-nameservers>                     (optional)\n    "domain": <name-of-local-domain>                         (optional)\n    "search": <list-of-additional-search-domains>            (optional)\n    "options": <list-of-options>                             (optional)\n  }\n}\n')])])]),t("blockquote",[t("p",[n._v("获取pod名称")])]),n._v(" "),t("p",[n._v("CNI_ARGS 环境变量存了一些额外信息, 值的格式为："),t("code",[n._v("FOO=BAR;ABC=123")]),n._v(", 比如其中就有我们挺需要的podname. "),t("code",[n._v("K8S_POD_NAME=xxxx")])]),n._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[n._v("#")]),n._v(" 总结")]),n._v(" "),t("p",[n._v("CNI接口层面是非常简单的，所以更多的就是在CNI本身的实现了，懂了上文这些就可以自己去实现一个CNI了,是不是很酷，也会让大家更熟悉网络以更从容的姿态排查网络问题了。")]),n._v(" "),t("p",[n._v("探讨可加QQ群：98488045")])])}),[],!1,null,null,null);e.default=r.exports}}]);