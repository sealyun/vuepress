(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{214:function(v,e,_){"use strict";_.r(e);var a=_(0),s=Object(a.a)({},(function(){var v=this,e=v.$createElement,_=v._self._c||e;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"设计理念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#设计理念"}},[v._v("#")]),v._v(" 设计理念")]),v._v(" "),_("h2",{attrs:{id:"概述与理念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#概述与理念"}},[v._v("#")]),v._v(" 概述与理念")]),v._v(" "),_("p",[v._v("sealos旨在做一个简单干净轻量级稳定的kubernetes安装工具，能很好的支持高可用安装。 其实把一个东西做的功能强大并不难，但是做到极简且灵活可扩展就比较难。")]),v._v(" "),_("p",[v._v("所以在实现时就必须要遵循这些原则。")]),v._v(" "),_("p",[v._v("sealos特性与优势：")]),v._v(" "),_("ul",[_("li",[v._v("支持离线安装，工具与资源包（二进制程序 配置文件 镜像 yaml文件等）分离,这样不同版本替换不同离线包即可")]),v._v(" "),_("li",[v._v("证书延期")]),v._v(" "),_("li",[v._v("使用简单")]),v._v(" "),_("li",[v._v("支持自定义配置")]),v._v(" "),_("li",[v._v("内核负载，极其稳定，因为简单所以排查问题也极其简单")])]),v._v(" "),_("blockquote",[_("p",[v._v("为什么不使用ansilbe")])]),v._v(" "),_("p",[v._v("1.0版本确实是用ansible实现，但是用户还是需要先装ansible，装ansible有需要装python和一些依赖等，为了不让用户那么麻烦把ansible放到了容器里供用户使用。如果不想配置免密钥使用用户名密码时又需要ssh-pass等，总之不能让我满意，不是我想的极简。")]),v._v(" "),_("p",[v._v("所以我想就来一个二进制文件工具，没有任何依赖，文件分发与远程命令都通过调用sdk实现所以不依赖其它任何东西，总算让我这个有洁癖的人满意了。")]),v._v(" "),_("blockquote",[_("p",[v._v("为什么不用keepalived haproxy")])]),v._v(" "),_("p",[v._v("haproxy用static pod跑没有太大问题还算好管理，keepalived现在大部分开源ansible脚本都用yum 或者apt等装，这样非常的不可控，有如下劣势：")]),v._v(" "),_("ul",[_("li",[v._v("源不一致可能导致版本不一致，版本不一直连配置文件都不一样，我曾经检测脚本不生效一直找不到原因，后来才知道是版本原因")]),v._v(" "),_("li",[v._v("系统原因安装不上，依赖库问题某些环境就直接装不上了")]),v._v(" "),_("li",[v._v("看了网上很多安装脚本，很多检测脚本与权重调节方式都不对，直接去检测haproxy进程在不在，其实是应该去检测apiserver是不是healthz的,api挂了即使haproxy在集群也会不正常了，就是伪高可用了。")]),v._v(" "),_("li",[v._v("管理不方便，通过prometheus对集群进行监控，是能直接监控到static pod的但是用systemd跑又需要单独设置监控，且重启啥的还需要单独拉起。不如kubelet统一管理来的干净简洁。")]),v._v(" "),_("li",[v._v("我们还出现过keepalived把CPU占满的情况。")])]),v._v(" "),_("p",[v._v("所以为了解决这个问题，我把keepalived跑在了容器中(社区提供的镜像基本是不可用的) 改造中间也是发生过很多问题，最终好在解决了。")]),v._v(" "),_("p",[v._v("总而言之，累觉不爱，所以在想能不能甩开haproxy和keepalived做出更简单更可靠的方案出来，还真找到了。。。")]),v._v(" "),_("blockquote",[_("p",[v._v("本地负载为什么不使用envoy或者nginx")])]),v._v(" "),_("p",[v._v("我们通过本地负载解决高可用问题")]),v._v(" "),_("p",[v._v("解释一下本地负载，就是在每个node节点上都启动一个负载均衡，上游就是三个master，负载方式有很多 ipvs envoy nginx等，我们最终使用内核ipvs")]),v._v(" "),_("p",[v._v("如果使用envoy等需要在每个节点上都跑一个进程，消耗更多资源，这是我不希望的。ipvs实际也多跑了一个进程lvscare，但是lvscare只是负责管理ipvs规则，和kube-proxy类似，真正的流量还是从很稳定的内核走的，不需要再把包走到用户态中去处理。")]),v._v(" "),_("p",[v._v("实现上有个问题会让使用envoy等变得非常尴尬，就是join时如果负载均衡没有建立那是会卡住的，kubelet就不会起，所以为此你需要先把envory起起来，意味着你又不能用static pod去管理它，同上面keepalived宿主机部署一样的问题，用static pod就会相互依赖，逻辑死锁，鸡说要先有蛋，蛋说要先有鸡，最后谁都没有。")]),v._v(" "),_("p",[v._v("使用ipvs就不一样，我可以在join之前先把ipvs规则建立好，再去join就可以join进去了，然后对规则进行守护即可。一旦apiserver不可访问了，会自动清理掉所有node上对应的ipvs规则， master恢复正常时添加回来。")]),v._v(" "),_("blockquote",[_("p",[v._v("为什么要定制kubeadm")])]),v._v(" "),_("p",[v._v("首先是由于kubeadm把证书时间写死了，所以需要定制把它改成99年，虽然大部分人可以自己去签个新证书，但是我们还是不想再依赖个别的工具，就直接改源码了。")]),v._v(" "),_("p",[v._v("其次就是做本地负载时修改kubeadm代码是最方便的，因为在join时我们需要做两个事，第一join之前先创建好ipvs规则，第二创建static pod，如果这块不去定制kubeadm就把报静态pod目录已存在的错误，忽略这个错误很不优雅。 而且kubeadm中已经提供了一些很好用的sdk供我们去实现这个功能。")]),v._v(" "),_("p",[v._v("且这样做之后最核心的功能都集成到kubeadm中了，sealos就单单变成分发和执行上层命令的轻量级工具了，增加节点时我们也就可以直接用kubeadm了")])])}),[],!1,null,null,null);e.default=s.exports}}]);